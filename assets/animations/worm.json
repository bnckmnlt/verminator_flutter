{"v":"5.5.3","fr":29.9700012207031,"ip":0,"op":102.000004154545,"w":1125,"h":1115,"nm":"Untitled-1","ddd":1,"assets":[],"layers":[{"ddd":0,"ind":1,"ty":3,"nm":"[CircularControl]1]_          Layer 1 Outlines","sr":1,"ks":{"o":{"a":0,"k":0,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[342.5,557.5,0],"ix":2},"a":{"a":0,"k":[10,10,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6}},"ao":0,"ef":[{"ty":5,"nm":"ACM","np":60,"mn":"Pseudo/5e36uID/ACM_3","ix":1,"en":1,"ef":[{"ty":6,"nm":"Pendulum","mn":"Pseudo/5e36uID/ACM_3-0001","ix":1,"v":0},{"ty":7,"nm":"Pendulum ON","mn":"Pseudo/5e36uID/ACM_3-0002","ix":2,"v":{"a":0,"k":0,"ix":2}},{"ty":0,"nm":"Angle(Pendulum only)","mn":"Pseudo/5e36uID/ACM_3-0003","ix":3,"v":{"a":0,"k":180,"ix":3}},{"ty":6,"nm":"","mn":"Pseudo/5e36uID/ACM_3-0004","ix":4,"v":0},{"ty":0,"nm":"Speed(XYZ)","mn":"Pseudo/5e36uID/ACM_3-0005","ix":5,"v":{"a":0,"k":59,"ix":5}},{"ty":3,"nm":"Scale XY","mn":"Pseudo/5e36uID/ACM_3-0006","ix":6,"v":{"a":0,"k":[0,28.25],"ix":6}},{"ty":0,"nm":"Scale  Z","mn":"Pseudo/5e36uID/ACM_3-0007","ix":7,"v":{"a":0,"k":0,"ix":7}},{"ty":0,"nm":"Offset","mn":"Pseudo/5e36uID/ACM_3-0008","ix":8,"v":{"a":0,"k":0,"ix":8}},{"ty":0,"nm":"Decay(Scale)","mn":"Pseudo/5e36uID/ACM_3-0009","ix":9,"v":{"a":0,"k":0,"ix":9}},{"ty":6,"nm":"Lag factor","mn":"Pseudo/5e36uID/ACM_3-0010","ix":10,"v":0},{"ty":0,"nm":"Shift","mn":"Pseudo/5e36uID/ACM_3-0011","ix":11,"v":{"a":0,"k":560,"ix":11,"x":"var $bm_rt;\n$bm_rt = $bm_sum(value, 0);"}},{"ty":3,"nm":"Speed XY","mn":"Pseudo/5e36uID/ACM_3-0012","ix":12,"v":{"a":0,"k":[0,0],"ix":12}},{"ty":0,"nm":"Speed Z","mn":"Pseudo/5e36uID/ACM_3-0013","ix":13,"v":{"a":0,"k":0,"ix":13}},{"ty":3,"nm":"Offset_XY","mn":"Pseudo/5e36uID/ACM_3-0014","ix":14,"v":{"a":0,"k":[0,0],"ix":14}},{"ty":0,"nm":"Offset__Z","mn":"Pseudo/5e36uID/ACM_3-0015","ix":15,"v":{"a":0,"k":0,"ix":15}},{"ty":0,"nm":"Scale(xy)","mn":"Pseudo/5e36uID/ACM_3-0016","ix":16,"v":{"a":0,"k":0,"ix":16}},{"ty":3,"nm":"Position XY","mn":"Pseudo/5e36uID/ACM_3-0017","ix":17,"v":{"a":0,"k":[500,0],"ix":17}},{"ty":0,"nm":"Position  Z","mn":"Pseudo/5e36uID/ACM_3-0018","ix":18,"v":{"a":0,"k":0,"ix":18}},{"ty":3,"nm":"Rotation XY","mn":"Pseudo/5e36uID/ACM_3-0019","ix":19,"v":{"a":0,"k":[0,0],"ix":19}},{"ty":0,"nm":"Rotation  Z","mn":"Pseudo/5e36uID/ACM_3-0020","ix":20,"v":{"a":0,"k":0,"ix":20}},{"ty":6,"nm":"","mn":"Pseudo/5e36uID/ACM_3-0021","ix":21,"v":0},{"ty":6,"nm":"Transform","mn":"Pseudo/5e36uID/ACM_3-0022","ix":22,"v":0},{"ty":6,"nm":"Position","mn":"Pseudo/5e36uID/ACM_3-0023","ix":23,"v":0},{"ty":3,"nm":"Position_XY","mn":"Pseudo/5e36uID/ACM_3-0024","ix":24,"v":{"a":0,"k":[0,0],"ix":24}},{"ty":0,"nm":"Position__Z","mn":"Pseudo/5e36uID/ACM_3-0025","ix":25,"v":{"a":0,"k":0,"ix":25}},{"ty":6,"nm":"","mn":"Pseudo/5e36uID/ACM_3-0026","ix":26,"v":0},{"ty":6,"nm":"Rotation","mn":"Pseudo/5e36uID/ACM_3-0027","ix":27,"v":0},{"ty":6,"nm":"FollowTarget","mn":"Pseudo/5e36uID/ACM_3-0028","ix":28,"v":0},{"ty":10,"nm":"Target","mn":"Pseudo/5e36uID/ACM_3-0029","ix":29,"v":{"a":0,"k":1,"ix":29}},{"ty":7,"nm":"FollowTarget_X","mn":"Pseudo/5e36uID/ACM_3-0030","ix":30,"v":{"a":0,"k":0,"ix":30}},{"ty":7,"nm":"FollowTarget_Y","mn":"Pseudo/5e36uID/ACM_3-0031","ix":31,"v":{"a":0,"k":0,"ix":31}},{"ty":7,"nm":"FollowTarget_Z","mn":"Pseudo/5e36uID/ACM_3-0032","ix":32,"v":{"a":0,"k":0,"ix":32}},{"ty":6,"nm":"","mn":"Pseudo/5e36uID/ACM_3-0033","ix":33,"v":0},{"ty":7,"nm":"AutoRotation_X","mn":"Pseudo/5e36uID/ACM_3-0034","ix":34,"v":{"a":0,"k":0,"ix":34}},{"ty":7,"nm":"AutoRotation_Y","mn":"Pseudo/5e36uID/ACM_3-0035","ix":35,"v":{"a":0,"k":0,"ix":35}},{"ty":7,"nm":"AutoRotation_Z","mn":"Pseudo/5e36uID/ACM_3-0036","ix":36,"v":{"a":0,"k":0,"ix":36}},{"ty":7,"nm":"ReverseRotation","mn":"Pseudo/5e36uID/ACM_3-0037","ix":37,"v":{"a":0,"k":0,"ix":37}},{"ty":0,"nm":"RotationX","mn":"Pseudo/5e36uID/ACM_3-0038","ix":38,"v":{"a":0,"k":0,"ix":38}},{"ty":0,"nm":"RotationY","mn":"Pseudo/5e36uID/ACM_3-0039","ix":39,"v":{"a":0,"k":0,"ix":39}},{"ty":0,"nm":"RotationZ","mn":"Pseudo/5e36uID/ACM_3-0040","ix":40,"v":{"a":0,"k":0,"ix":40}},{"ty":6,"nm":"","mn":"Pseudo/5e36uID/ACM_3-0041","ix":41,"v":0},{"ty":6,"nm":"Scale","mn":"Pseudo/5e36uID/ACM_3-0042","ix":42,"v":0},{"ty":3,"nm":"Scale_XY(%)","mn":"Pseudo/5e36uID/ACM_3-0043","ix":43,"v":{"a":0,"k":[100,100],"ix":43}},{"ty":0,"nm":"Scale__Z","mn":"Pseudo/5e36uID/ACM_3-0044","ix":44,"v":{"a":0,"k":100,"ix":44}},{"ty":6,"nm":"","mn":"Pseudo/5e36uID/ACM_3-0045","ix":45,"v":0},{"ty":6,"nm":"Opacity","mn":"Pseudo/5e36uID/ACM_3-0046","ix":46,"v":0},{"ty":0,"nm":"Opacity(0~100)","mn":"Pseudo/5e36uID/ACM_3-0047","ix":47,"v":{"a":0,"k":100,"ix":47}},{"ty":6,"nm":"","mn":"Pseudo/5e36uID/ACM_3-0048","ix":48,"v":0},{"ty":6,"nm":"Anchorpoint","mn":"Pseudo/5e36uID/ACM_3-0049","ix":49,"v":0},{"ty":3,"nm":"Anchorpoint_XY","mn":"Pseudo/5e36uID/ACM_3-0050","ix":50,"v":{"a":0,"k":[0,0],"ix":50}},{"ty":0,"nm":"Anchorpoint__Z","mn":"Pseudo/5e36uID/ACM_3-0051","ix":51,"v":{"a":0,"k":0,"ix":51}},{"ty":6,"nm":"","mn":"Pseudo/5e36uID/ACM_3-0052","ix":52,"v":0},{"ty":6,"nm":"","mn":"Pseudo/5e36uID/ACM_3-0053","ix":53,"v":0},{"ty":6,"nm":"Bounce(CircularMotionOnly)","mn":"Pseudo/5e36uID/ACM_3-0054","ix":54,"v":0},{"ty":7,"nm":"Bounce_X","mn":"Pseudo/5e36uID/ACM_3-0055","ix":55,"v":{"a":0,"k":0,"ix":55}},{"ty":7,"nm":"Bounce_Y","mn":"Pseudo/5e36uID/ACM_3-0056","ix":56,"v":{"a":0,"k":0,"ix":56}},{"ty":7,"nm":"Bounce_Z","mn":"Pseudo/5e36uID/ACM_3-0057","ix":57,"v":{"a":0,"k":0,"ix":57}},{"ty":6,"nm":"","mn":"Pseudo/5e36uID/ACM_3-0058","ix":58,"v":0}]},{"ty":5,"nm":"ACM_speedXYZ[delete prohibited]","np":3,"mn":"ADBE Slider Control","ix":2,"en":1,"ef":[{"ty":0,"nm":"Slider","mn":"ADBE Slider Control-0001","ix":1,"v":{"a":0,"k":0,"ix":1,"x":"var $bm_rt;\nvar sp, nKey1, nKey1, i, sp, sp;\nsp = 0;\ntry {\n    $bm_rt = nKey1 = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Speed(XYZ)').nearestKey(0);\n} catch (e) {\n    $bm_rt = nKey1 = 'null';\n}\n;\nif (nKey1 != 'null') {\n    i = 0;\n    while (i - 0.01 + inPoint <= time) {\n        sp = $bm_sum(sp, $bm_mul($bm_div(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Speed(XYZ)').valueAtTime($bm_sum(i, inPoint)), 29.9700012207031), -0.02));\n        i = $bm_sum(i, 1 / 29.9700012207031);\n    }\n    ;\n    sp = $bm_sum(sp, $bm_div($bm_mul($bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Speed(XYZ)'), 0.02), 1), 29.9700012207031));\n    $bm_rt = $bm_div(Math.floor($bm_mul(sp, 1000)), 1000);\n} else {\n    $bm_rt = sp = $bm_mul($bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Speed(XYZ)'), -0.02), $bm_sub(time, inPoint));\n}\n;"}}]}],"ip":0,"op":900.000036657751,"st":0,"bm":0,"completed":true},{"ddd":1,"ind":2,"ty":4,"nm":"          Layer 8 Outlines","parent":1,"sr":1,"ks":{"o":{"a":0,"k":100,"ix":11,"x":"var $bm_rt;\n$bm_rt = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Opacity(0~100)');"},"rx":{"a":0,"k":0,"ix":8,"x":"var $bm_rt;\nvar no, lag, rotax, r, r, rota, cycle, gtime, nKey, gtime, gtime, decay, gtime, nKey, ttx, ttx, cycle, ttx, cycle, baseTime, min, max, UP, Down;\nno = 8;\nlag = $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Rotation XY'), 0.1);\nrotax = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('RotationX');\nif (thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('ReverseRotation') == 1) {\n    r = 1;\n} else {\n    r = -1;\n}\n;\n$bm_rt = rota = $bm_mul(lag[0], no);\nif (thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('AutoRotation_X') == 1) {\n    cycle = $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Speed(XYZ)'), 0.01);\n    gtime = 0;\n    try {\n        nKey = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Decay(Scale)').nearestKey(0);\n        if (time >= nKey.time) {\n            gtime = $bm_sub(time, nKey.time);\n        } else {\n            gtime = $bm_sub(time, nKey.time);\n            if (gtime < 0) {\n                decay = 0;\n            }\n        }\n    } catch (e) {\n        gtime = time;\n        nKey = 'NaN';\n    }\n    ;\n    if (nKey == 'NaN') {\n        ttx = $bm_sub(time, thisLayer.inPoint);\n    } else {\n        ttx = gtime;\n    }\n    ;\n    cycle = $bm_mul(cycle, Math.exp($bm_mul($bm_mul(ttx, thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Decay(Scale)')), 0.01)));\n    if (cycle == 0) {\n        ttx = 1;\n        cycle = 1;\n    }\n    ;\n    baseTime = $bm_mod(ttx, $bm_div(1, cycle));\n    min = 0;\n    max = $bm_mul(360, r);\n    UP = linear(baseTime, 0, $bm_div(1, cycle), min, max);\n    Down = linear(baseTime, $bm_div(1, cycle), cycle, max, min);\n    $bm_rt = baseTime < $bm_div(1, cycle) ? $bm_sum($bm_sum($bm_sum(UP, value), rota), rotax) : $bm_sum($bm_sum($bm_sum(Down, value), rota), rotax);\n} else {\n    $bm_rt = $bm_sum($bm_sum(value, rota), rotax);\n}"},"ry":{"a":0,"k":0,"ix":9,"x":"var $bm_rt;\nvar no, lag, rotay, r, r, rota, cycle, gtime, nKey, gtime, gtime, decay, gtime, nKey, ttx, ttx, cycle, ttx, cycle, baseTime, min, max, UP, Down;\nno = 8;\nlag = $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Rotation XY'), 0.1);\nrotay = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('RotationY');\nif (thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('ReverseRotation') == 1) {\n    r = 1;\n} else {\n    r = -1;\n}\n;\n$bm_rt = rota = $bm_mul(lag[1], no);\nif (thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('AutoRotation_Y') == 1) {\n    cycle = $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Speed(XYZ)'), 0.01);\n    gtime = 0;\n    try {\n        nKey = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Decay(Scale)').nearestKey(0);\n        if (time >= nKey.time) {\n            gtime = $bm_sub(time, nKey.time);\n        } else {\n            gtime = $bm_sub(time, nKey.time);\n            if (gtime < 0) {\n                decay = 0;\n            }\n        }\n    } catch (e) {\n        gtime = time;\n        nKey = 'NaN';\n    }\n    ;\n    if (nKey == 'NaN') {\n        ttx = $bm_sub(time, thisLayer.inPoint);\n    } else {\n        ttx = gtime;\n    }\n    ;\n    cycle = $bm_mul(cycle, Math.exp($bm_mul($bm_mul(ttx, thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Decay(Scale)')), 0.01)));\n    if (cycle == 0) {\n        ttx = 1;\n        cycle = 1;\n    }\n    ;\n    baseTime = $bm_mod(ttx, $bm_div(1, cycle));\n    min = 0;\n    max = $bm_mul(360, r);\n    UP = linear(baseTime, 0, $bm_div(1, cycle), min, max);\n    Down = linear(baseTime, $bm_div(1, cycle), cycle, max, min);\n    $bm_rt = baseTime < $bm_div(1, cycle) ? $bm_sum($bm_sum($bm_sum(UP, value), rota), rotay) : $bm_sum($bm_sum($bm_sum(Down, value), rota), rotay);\n} else {\n    $bm_rt = $bm_sum($bm_sum(value, rota), rotay);\n}"},"rz":{"a":0,"k":0,"ix":10,"x":"var $bm_rt;\nvar no, lag, rotaz, r, r, rota, cycle, gtime, nKey, gtime, gtime, decay, gtime, nKey, ttx, ttx, cycle, ttx, cycle, baseTime, min, max, UP, Down;\nno = 8;\nlag = $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Rotation  Z'), 0.1);\nrotaz = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('RotationZ');\nif (thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('ReverseRotation') == 1) {\n    r = 1;\n} else {\n    r = -1;\n}\n;\n$bm_rt = rota = $bm_mul(lag, no);\nif (thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('AutoRotation_Z') == 1) {\n    cycle = $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Speed(XYZ)'), 0.01);\n    gtime = 0;\n    try {\n        nKey = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Decay(Scale)').nearestKey(0);\n        if (time >= nKey.time) {\n            gtime = $bm_sub(time, nKey.time);\n        } else {\n            gtime = $bm_sub(time, nKey.time);\n            if (gtime < 0) {\n                decay = 0;\n            }\n        }\n    } catch (e) {\n        gtime = time;\n        nKey = 'NaN';\n    }\n    ;\n    if (nKey == 'NaN') {\n        ttx = $bm_sub(time, thisLayer.inPoint);\n    } else {\n        ttx = gtime;\n    }\n    ;\n    cycle = $bm_mul(cycle, Math.exp($bm_mul($bm_mul(ttx, thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Decay(Scale)')), 0.01)));\n    if (cycle == 0) {\n        ttx = 1;\n        cycle = 1;\n    }\n    ;\n    baseTime = $bm_mod(ttx, $bm_div(1, cycle));\n    min = 0;\n    max = $bm_mul(360, r);\n    UP = linear(baseTime, 0, $bm_div(1, cycle), min, max);\n    Down = linear(baseTime, $bm_div(1, cycle), cycle, max, min);\n    $bm_rt = baseTime < $bm_div(1, cycle) ? $bm_sum($bm_sum($bm_sum(UP, value), rota), rotaz) : $bm_sum($bm_sum($bm_sum(Down, value), rota), rotaz);\n} else {\n    $bm_rt = $bm_sum($bm_sum(value, rota), rotaz);\n}"},"or":{"a":0,"k":[0,0,0],"ix":7,"x":"var $bm_rt;\nvar a, o, tr, tr, o, o, o;\na = [\n    0,\n    0,\n    0\n];\no = [\n    0,\n    0,\n    0\n];\ntry {\n    tr = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Target');\n} catch (e) {\n    tr = 0;\n}\nif (tr != 0) {\n    try {\n        if (this.parent) {\n            o = lookAt($bm_sum($bm_transform.position, this.parent.position), tr.position);\n        } else {\n            o = lookAt($bm_transform.position, tr.position);\n        }\n        ;\n    } catch (e) {\n        o = lookAt($bm_transform.position, tr.position);\n    }\n}\n;\nif (thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('FollowTarget_X') == 1) {\n    a[0] = o[0];\n}\nif (thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('FollowTarget_Y') == 1) {\n    a[1] = o[1];\n}\nif (thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('FollowTarget_Z') == 1) {\n    a[2] = o[2];\n}\n$bm_rt = $bm_sum(a, value);"},"p":{"a":0,"k":[10,10,0],"ix":2,"x":"var $bm_rt;\nvar huriko, bounceX, bounceY, bounceZ, rangexy, rangez, angle, offset, lag, lagren, lposxy, lposz, decay, displacementXYZ, splagXY, splagZ, gtime, nKey, gtime, gtime, decay, gtime, nKey, ttx, ttx, posxy, posz, stime, range, offset, lagx, lagy, lagz, offsetXY, offsetZ, offsetZ, decayspeed, displacementXYZ, rangexy, x, y, z, x, x, y, y, z, z;\nvar no = 8;\nhuriko = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Pendulum ON');\nbounceX = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Bounce_X');\nbounceY = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Bounce_Y');\nbounceZ = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Bounce_Z');\nrangexy = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Scale XY');\nrangez = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Scale  Z');\nangle = degreesToRadians($bm_sum(180, $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Angle(Pendulum only)'), -1)));\noffset = $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Offset'), 0.01);\nlag = $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Shift'), 0.01);\nlagren = $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Scale(xy)'), 0.1);\nlposxy = $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Position XY'), 0.1);\nlposz = $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Position  Z'), 0.1);\ndecay = $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Decay(Scale)'), 0.01);\ndisplacementXYZ = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM_speedXYZ[delete prohibited]')('ADBE Slider Control-0001');\nsplagXY = $bm_sum([\n    1,\n    1\n], $bm_mul($bm_mul(no, thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Speed XY')), 0.0001));\nsplagZ = $bm_sum(1, $bm_mul($bm_mul(no, thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Speed Z')), 0.0001));\ngtime = 0;\ntry {\n    nKey = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Decay(Scale)').nearestKey(0);\n    if (time >= nKey.time) {\n        gtime = $bm_sub(time, nKey.time);\n    } else {\n        gtime = $bm_sub(time, nKey.time);\n        if (gtime < 0) {\n            decay = 0;\n        }\n    }\n} catch (e) {\n    gtime = time;\n    nKey = 'NaN';\n}\n;\nif (nKey == 'NaN') {\n    ttx = $bm_sub(time, thisLayer.inPoint);\n} else {\n    ttx = gtime;\n}\n;\nposxy = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Position_XY');\nposz = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Position__Z');\nstime = 1;\nrange = 100;\noffset = $bm_sum(offset, $bm_mul(lag, no));\nlagx = $bm_mul(lposxy[0], no);\nlagy = $bm_mul(lposxy[1], no);\nlagz = $bm_mul(lposz, no);\noffsetXY = $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Offset_XY'), 0.001);\noffsetZ = $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Offset__Z'), 0.001);\noffsetXY[0] = $bm_sum(offset, $bm_mul(offsetXY[0], no));\noffsetXY[1] = $bm_sum(offset, $bm_mul(offsetXY[1], no));\noffsetZ = $bm_sum(offset, $bm_mul(offsetZ, no));\ndecayspeed = $bm_mul(Math.abs(decay), 0.2);\ndisplacementXYZ = $bm_mul(displacementXYZ, Math.exp($bm_mul(ttx, decayspeed)));\n$bm_rt = rangexy = $bm_sum(rangexy, [\n    $bm_mul(lagren, no),\n    $bm_mul(lagren, no)\n]);\nif (huriko == true) {\n    x = $bm_mul(Math.sin($bm_sum($bm_mul($bm_mul($bm_mul(splagXY[0], displacementXYZ), Math.PI), stime), offsetXY[0])), Math.exp($bm_mul(ttx, decay)));\n    y = $bm_mul(Math.sin($bm_sum($bm_mul($bm_mul($bm_mul(splagXY[1], displacementXYZ), Math.PI), stime), offsetXY[1])), Math.exp($bm_mul(ttx, decay)));\n    z = $bm_mul(Math.sin($bm_sum($bm_mul($bm_mul($bm_mul(splagZ, displacementXYZ), Math.PI), stime), offsetZ)), Math.exp($bm_mul(ttx, decay)));\n    try {\n        $bm_rt = [\n            rangexy[0] * Math.sin(x * (range * 0.01) + angle) + value[0] + posxy[0] + lagx,\n            rangexy[1] * Math.cos(y * (range * 0.01) + angle) + value[1] + posxy[1] + lagy,\n            rangez * Math.cos(z * (range * 0.01) + angle) + value[2] + posz + lagz\n        ];\n    } catch (e) {\n        $bm_rt = [\n            rangexy[0] * Math.sin(x * (range * 0.01) + angle) + value[0] + posxy[0] + lagx,\n            rangexy[1] * Math.cos(y * (range * 0.01) + angle) + value[1] + posxy[1] + lagy\n        ];\n    }\n} else {\n    x = $bm_mul($bm_mul(rangexy[0], Math.sin($bm_sum($bm_mul($bm_mul($bm_mul(splagXY[0], displacementXYZ), Math.PI), stime), offsetXY[0]))), Math.exp($bm_mul(ttx, decay)));\n    if (bounceX != false) {\n        x = Math.abs(x);\n    }\n    y = $bm_mul($bm_mul(rangexy[1], Math.cos($bm_sum($bm_mul($bm_mul($bm_mul(splagXY[1], displacementXYZ), Math.PI), stime), offsetXY[1]))), Math.exp($bm_mul(ttx, decay)));\n    if (bounceY != false) {\n        y = $bm_mul(Math.abs(y), -1);\n    }\n    z = $bm_mul($bm_mul(rangez, Math.cos($bm_sum($bm_mul($bm_mul($bm_mul(splagZ, displacementXYZ), Math.PI), stime), offsetZ))), Math.exp($bm_mul(ttx, decay)));\n    if (bounceZ != false) {\n        z = Math.abs(z);\n    }\n    try {\n        $bm_rt = [\n            x + value[0] + posxy[0] + lagx,\n            y + value[1] + posxy[1] + lagy,\n            z + value[2] + posz + lagz\n        ];\n    } catch (e) {\n        $bm_rt = [\n            x + value[0] + posxy[0] + lagx,\n            y + value[1] + posxy[1] + lagy\n        ];\n    }\n}"},"a":{"a":0,"k":[826.949,574,0],"ix":1,"x":"var $bm_rt;\nvar a, b;\na = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Anchorpoint_XY');\nb = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Anchorpoint__Z');\ntry {\n    $bm_rt = [\n        a[0] + value[0],\n        a[1] + value[1],\n        b + value[2]\n    ];\n} catch (e) {\n    $bm_rt = [\n        a[0] + value[0],\n        a[1] + value[1]\n    ];\n}"},"s":{"a":0,"k":[330,330,330],"ix":6,"x":"var $bm_rt;\nvar a, b;\na = $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Scale_XY(%)'), 0.01);\nb = $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Scale__Z'), 0.01);\ntry {\n    $bm_rt = [\n        a[0] * value[0],\n        a[1] * value[1],\n        b * value[2]\n    ];\n} catch (e) {\n    $bm_rt = [\n        a[0] * value[0],\n        a[1] * value[1]\n    ];\n}"}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[23.051,-12.73],[12.731,23.051],[-23.05,12.73],[-12.73,-23.051]],"o":[[23.051,12.73],[-12.73,23.051],[-23.05,-12.73],[12.731,-23.051]],"v":[[23.051,0],[0,23.051],[-23.05,0],[0,-23.051]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false,"_render":true},{"ty":"fl","c":{"a":0,"k":[0.0902,0.1529,0.2275,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false,"_render":true},{"ty":"tr","p":{"a":0,"k":[826.949,574],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform","_render":true}],"nm":"Group 1","np":2,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false,"_render":true}],"ip":0,"op":900.000036657751,"st":0,"bm":0,"completed":true},{"ddd":1,"ind":3,"ty":4,"nm":"          Layer 7 Outlines","parent":1,"sr":1,"ks":{"o":{"a":0,"k":100,"ix":11,"x":"var $bm_rt;\n$bm_rt = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Opacity(0~100)');"},"rx":{"a":0,"k":0,"ix":8,"x":"var $bm_rt;\nvar no, lag, rotax, r, r, rota, cycle, gtime, nKey, gtime, gtime, decay, gtime, nKey, ttx, ttx, cycle, ttx, cycle, baseTime, min, max, UP, Down;\nno = 7;\nlag = $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Rotation XY'), 0.1);\nrotax = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('RotationX');\nif (thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('ReverseRotation') == 1) {\n    r = 1;\n} else {\n    r = -1;\n}\n;\n$bm_rt = rota = $bm_mul(lag[0], no);\nif (thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('AutoRotation_X') == 1) {\n    cycle = $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Speed(XYZ)'), 0.01);\n    gtime = 0;\n    try {\n        nKey = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Decay(Scale)').nearestKey(0);\n        if (time >= nKey.time) {\n            gtime = $bm_sub(time, nKey.time);\n        } else {\n            gtime = $bm_sub(time, nKey.time);\n            if (gtime < 0) {\n                decay = 0;\n            }\n        }\n    } catch (e) {\n        gtime = time;\n        nKey = 'NaN';\n    }\n    ;\n    if (nKey == 'NaN') {\n        ttx = $bm_sub(time, thisLayer.inPoint);\n    } else {\n        ttx = gtime;\n    }\n    ;\n    cycle = $bm_mul(cycle, Math.exp($bm_mul($bm_mul(ttx, thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Decay(Scale)')), 0.01)));\n    if (cycle == 0) {\n        ttx = 1;\n        cycle = 1;\n    }\n    ;\n    baseTime = $bm_mod(ttx, $bm_div(1, cycle));\n    min = 0;\n    max = $bm_mul(360, r);\n    UP = linear(baseTime, 0, $bm_div(1, cycle), min, max);\n    Down = linear(baseTime, $bm_div(1, cycle), cycle, max, min);\n    $bm_rt = baseTime < $bm_div(1, cycle) ? $bm_sum($bm_sum($bm_sum(UP, value), rota), rotax) : $bm_sum($bm_sum($bm_sum(Down, value), rota), rotax);\n} else {\n    $bm_rt = $bm_sum($bm_sum(value, rota), rotax);\n}"},"ry":{"a":0,"k":0,"ix":9,"x":"var $bm_rt;\nvar no, lag, rotay, r, r, rota, cycle, gtime, nKey, gtime, gtime, decay, gtime, nKey, ttx, ttx, cycle, ttx, cycle, baseTime, min, max, UP, Down;\nno = 7;\nlag = $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Rotation XY'), 0.1);\nrotay = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('RotationY');\nif (thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('ReverseRotation') == 1) {\n    r = 1;\n} else {\n    r = -1;\n}\n;\n$bm_rt = rota = $bm_mul(lag[1], no);\nif (thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('AutoRotation_Y') == 1) {\n    cycle = $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Speed(XYZ)'), 0.01);\n    gtime = 0;\n    try {\n        nKey = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Decay(Scale)').nearestKey(0);\n        if (time >= nKey.time) {\n            gtime = $bm_sub(time, nKey.time);\n        } else {\n            gtime = $bm_sub(time, nKey.time);\n            if (gtime < 0) {\n                decay = 0;\n            }\n        }\n    } catch (e) {\n        gtime = time;\n        nKey = 'NaN';\n    }\n    ;\n    if (nKey == 'NaN') {\n        ttx = $bm_sub(time, thisLayer.inPoint);\n    } else {\n        ttx = gtime;\n    }\n    ;\n    cycle = $bm_mul(cycle, Math.exp($bm_mul($bm_mul(ttx, thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Decay(Scale)')), 0.01)));\n    if (cycle == 0) {\n        ttx = 1;\n        cycle = 1;\n    }\n    ;\n    baseTime = $bm_mod(ttx, $bm_div(1, cycle));\n    min = 0;\n    max = $bm_mul(360, r);\n    UP = linear(baseTime, 0, $bm_div(1, cycle), min, max);\n    Down = linear(baseTime, $bm_div(1, cycle), cycle, max, min);\n    $bm_rt = baseTime < $bm_div(1, cycle) ? $bm_sum($bm_sum($bm_sum(UP, value), rota), rotay) : $bm_sum($bm_sum($bm_sum(Down, value), rota), rotay);\n} else {\n    $bm_rt = $bm_sum($bm_sum(value, rota), rotay);\n}"},"rz":{"a":0,"k":0,"ix":10,"x":"var $bm_rt;\nvar no, lag, rotaz, r, r, rota, cycle, gtime, nKey, gtime, gtime, decay, gtime, nKey, ttx, ttx, cycle, ttx, cycle, baseTime, min, max, UP, Down;\nno = 7;\nlag = $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Rotation  Z'), 0.1);\nrotaz = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('RotationZ');\nif (thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('ReverseRotation') == 1) {\n    r = 1;\n} else {\n    r = -1;\n}\n;\n$bm_rt = rota = $bm_mul(lag, no);\nif (thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('AutoRotation_Z') == 1) {\n    cycle = $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Speed(XYZ)'), 0.01);\n    gtime = 0;\n    try {\n        nKey = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Decay(Scale)').nearestKey(0);\n        if (time >= nKey.time) {\n            gtime = $bm_sub(time, nKey.time);\n        } else {\n            gtime = $bm_sub(time, nKey.time);\n            if (gtime < 0) {\n                decay = 0;\n            }\n        }\n    } catch (e) {\n        gtime = time;\n        nKey = 'NaN';\n    }\n    ;\n    if (nKey == 'NaN') {\n        ttx = $bm_sub(time, thisLayer.inPoint);\n    } else {\n        ttx = gtime;\n    }\n    ;\n    cycle = $bm_mul(cycle, Math.exp($bm_mul($bm_mul(ttx, thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Decay(Scale)')), 0.01)));\n    if (cycle == 0) {\n        ttx = 1;\n        cycle = 1;\n    }\n    ;\n    baseTime = $bm_mod(ttx, $bm_div(1, cycle));\n    min = 0;\n    max = $bm_mul(360, r);\n    UP = linear(baseTime, 0, $bm_div(1, cycle), min, max);\n    Down = linear(baseTime, $bm_div(1, cycle), cycle, max, min);\n    $bm_rt = baseTime < $bm_div(1, cycle) ? $bm_sum($bm_sum($bm_sum(UP, value), rota), rotaz) : $bm_sum($bm_sum($bm_sum(Down, value), rota), rotaz);\n} else {\n    $bm_rt = $bm_sum($bm_sum(value, rota), rotaz);\n}"},"or":{"a":0,"k":[0,0,0],"ix":7,"x":"var $bm_rt;\nvar a, o, tr, tr, o, o, o;\na = [\n    0,\n    0,\n    0\n];\no = [\n    0,\n    0,\n    0\n];\ntry {\n    tr = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Target');\n} catch (e) {\n    tr = 0;\n}\nif (tr != 0) {\n    try {\n        if (this.parent) {\n            o = lookAt($bm_sum($bm_transform.position, this.parent.position), tr.position);\n        } else {\n            o = lookAt($bm_transform.position, tr.position);\n        }\n        ;\n    } catch (e) {\n        o = lookAt($bm_transform.position, tr.position);\n    }\n}\n;\nif (thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('FollowTarget_X') == 1) {\n    a[0] = o[0];\n}\nif (thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('FollowTarget_Y') == 1) {\n    a[1] = o[1];\n}\nif (thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('FollowTarget_Z') == 1) {\n    a[2] = o[2];\n}\n$bm_rt = $bm_sum(a, value);"},"p":{"a":0,"k":[10,10,0],"ix":2,"x":"var $bm_rt;\nvar huriko, bounceX, bounceY, bounceZ, rangexy, rangez, angle, offset, lag, lagren, lposxy, lposz, decay, displacementXYZ, splagXY, splagZ, gtime, nKey, gtime, gtime, decay, gtime, nKey, ttx, ttx, posxy, posz, stime, range, offset, lagx, lagy, lagz, offsetXY, offsetZ, offsetZ, decayspeed, displacementXYZ, rangexy, x, y, z, x, x, y, y, z, z;\nvar no = 7;\nhuriko = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Pendulum ON');\nbounceX = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Bounce_X');\nbounceY = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Bounce_Y');\nbounceZ = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Bounce_Z');\nrangexy = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Scale XY');\nrangez = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Scale  Z');\nangle = degreesToRadians($bm_sum(180, $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Angle(Pendulum only)'), -1)));\noffset = $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Offset'), 0.01);\nlag = $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Shift'), 0.01);\nlagren = $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Scale(xy)'), 0.1);\nlposxy = $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Position XY'), 0.1);\nlposz = $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Position  Z'), 0.1);\ndecay = $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Decay(Scale)'), 0.01);\ndisplacementXYZ = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM_speedXYZ[delete prohibited]')('ADBE Slider Control-0001');\nsplagXY = $bm_sum([\n    1,\n    1\n], $bm_mul($bm_mul(no, thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Speed XY')), 0.0001));\nsplagZ = $bm_sum(1, $bm_mul($bm_mul(no, thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Speed Z')), 0.0001));\ngtime = 0;\ntry {\n    nKey = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Decay(Scale)').nearestKey(0);\n    if (time >= nKey.time) {\n        gtime = $bm_sub(time, nKey.time);\n    } else {\n        gtime = $bm_sub(time, nKey.time);\n        if (gtime < 0) {\n            decay = 0;\n        }\n    }\n} catch (e) {\n    gtime = time;\n    nKey = 'NaN';\n}\n;\nif (nKey == 'NaN') {\n    ttx = $bm_sub(time, thisLayer.inPoint);\n} else {\n    ttx = gtime;\n}\n;\nposxy = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Position_XY');\nposz = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Position__Z');\nstime = 1;\nrange = 100;\noffset = $bm_sum(offset, $bm_mul(lag, no));\nlagx = $bm_mul(lposxy[0], no);\nlagy = $bm_mul(lposxy[1], no);\nlagz = $bm_mul(lposz, no);\noffsetXY = $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Offset_XY'), 0.001);\noffsetZ = $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Offset__Z'), 0.001);\noffsetXY[0] = $bm_sum(offset, $bm_mul(offsetXY[0], no));\noffsetXY[1] = $bm_sum(offset, $bm_mul(offsetXY[1], no));\noffsetZ = $bm_sum(offset, $bm_mul(offsetZ, no));\ndecayspeed = $bm_mul(Math.abs(decay), 0.2);\ndisplacementXYZ = $bm_mul(displacementXYZ, Math.exp($bm_mul(ttx, decayspeed)));\n$bm_rt = rangexy = $bm_sum(rangexy, [\n    $bm_mul(lagren, no),\n    $bm_mul(lagren, no)\n]);\nif (huriko == true) {\n    x = $bm_mul(Math.sin($bm_sum($bm_mul($bm_mul($bm_mul(splagXY[0], displacementXYZ), Math.PI), stime), offsetXY[0])), Math.exp($bm_mul(ttx, decay)));\n    y = $bm_mul(Math.sin($bm_sum($bm_mul($bm_mul($bm_mul(splagXY[1], displacementXYZ), Math.PI), stime), offsetXY[1])), Math.exp($bm_mul(ttx, decay)));\n    z = $bm_mul(Math.sin($bm_sum($bm_mul($bm_mul($bm_mul(splagZ, displacementXYZ), Math.PI), stime), offsetZ)), Math.exp($bm_mul(ttx, decay)));\n    try {\n        $bm_rt = [\n            rangexy[0] * Math.sin(x * (range * 0.01) + angle) + value[0] + posxy[0] + lagx,\n            rangexy[1] * Math.cos(y * (range * 0.01) + angle) + value[1] + posxy[1] + lagy,\n            rangez * Math.cos(z * (range * 0.01) + angle) + value[2] + posz + lagz\n        ];\n    } catch (e) {\n        $bm_rt = [\n            rangexy[0] * Math.sin(x * (range * 0.01) + angle) + value[0] + posxy[0] + lagx,\n            rangexy[1] * Math.cos(y * (range * 0.01) + angle) + value[1] + posxy[1] + lagy\n        ];\n    }\n} else {\n    x = $bm_mul($bm_mul(rangexy[0], Math.sin($bm_sum($bm_mul($bm_mul($bm_mul(splagXY[0], displacementXYZ), Math.PI), stime), offsetXY[0]))), Math.exp($bm_mul(ttx, decay)));\n    if (bounceX != false) {\n        x = Math.abs(x);\n    }\n    y = $bm_mul($bm_mul(rangexy[1], Math.cos($bm_sum($bm_mul($bm_mul($bm_mul(splagXY[1], displacementXYZ), Math.PI), stime), offsetXY[1]))), Math.exp($bm_mul(ttx, decay)));\n    if (bounceY != false) {\n        y = $bm_mul(Math.abs(y), -1);\n    }\n    z = $bm_mul($bm_mul(rangez, Math.cos($bm_sum($bm_mul($bm_mul($bm_mul(splagZ, displacementXYZ), Math.PI), stime), offsetZ))), Math.exp($bm_mul(ttx, decay)));\n    if (bounceZ != false) {\n        z = Math.abs(z);\n    }\n    try {\n        $bm_rt = [\n            x + value[0] + posxy[0] + lagx,\n            y + value[1] + posxy[1] + lagy,\n            z + value[2] + posz + lagz\n        ];\n    } catch (e) {\n        $bm_rt = [\n            x + value[0] + posxy[0] + lagx,\n            y + value[1] + posxy[1] + lagy\n        ];\n    }\n}"},"a":{"a":0,"k":[749.107,574,0],"ix":1,"x":"var $bm_rt;\nvar a, b;\na = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Anchorpoint_XY');\nb = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Anchorpoint__Z');\ntry {\n    $bm_rt = [\n        a[0] + value[0],\n        a[1] + value[1],\n        b + value[2]\n    ];\n} catch (e) {\n    $bm_rt = [\n        a[0] + value[0],\n        a[1] + value[1]\n    ];\n}"},"s":{"a":0,"k":[330,330,330],"ix":6,"x":"var $bm_rt;\nvar a, b;\na = $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Scale_XY(%)'), 0.01);\nb = $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Scale__Z'), 0.01);\ntry {\n    $bm_rt = [\n        a[0] * value[0],\n        a[1] * value[1],\n        b * value[2]\n    ];\n} catch (e) {\n    $bm_rt = [\n        a[0] * value[0],\n        a[1] * value[1]\n    ];\n}"}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[23.051,-12.73],[12.731,23.051],[-23.05,12.73],[-12.73,-23.051]],"o":[[23.051,12.73],[-12.73,23.051],[-23.05,-12.73],[12.731,-23.051]],"v":[[23.051,0],[0,23.051],[-23.05,0],[0,-23.051]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false,"_render":true},{"ty":"fl","c":{"a":0,"k":[0.1352,0.6075,0.9448,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false,"_render":true},{"ty":"tr","p":{"a":0,"k":[749.107,574],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform","_render":true}],"nm":"Group 1","np":2,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false,"_render":true}],"ip":0,"op":900.000036657751,"st":0,"bm":0,"completed":true},{"ddd":1,"ind":4,"ty":4,"nm":"          Layer 6 Outlines","parent":1,"sr":1,"ks":{"o":{"a":0,"k":100,"ix":11,"x":"var $bm_rt;\n$bm_rt = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Opacity(0~100)');"},"rx":{"a":0,"k":0,"ix":8,"x":"var $bm_rt;\nvar no, lag, rotax, r, r, rota, cycle, gtime, nKey, gtime, gtime, decay, gtime, nKey, ttx, ttx, cycle, ttx, cycle, baseTime, min, max, UP, Down;\nno = 6;\nlag = $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Rotation XY'), 0.1);\nrotax = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('RotationX');\nif (thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('ReverseRotation') == 1) {\n    r = 1;\n} else {\n    r = -1;\n}\n;\n$bm_rt = rota = $bm_mul(lag[0], no);\nif (thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('AutoRotation_X') == 1) {\n    cycle = $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Speed(XYZ)'), 0.01);\n    gtime = 0;\n    try {\n        nKey = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Decay(Scale)').nearestKey(0);\n        if (time >= nKey.time) {\n            gtime = $bm_sub(time, nKey.time);\n        } else {\n            gtime = $bm_sub(time, nKey.time);\n            if (gtime < 0) {\n                decay = 0;\n            }\n        }\n    } catch (e) {\n        gtime = time;\n        nKey = 'NaN';\n    }\n    ;\n    if (nKey == 'NaN') {\n        ttx = $bm_sub(time, thisLayer.inPoint);\n    } else {\n        ttx = gtime;\n    }\n    ;\n    cycle = $bm_mul(cycle, Math.exp($bm_mul($bm_mul(ttx, thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Decay(Scale)')), 0.01)));\n    if (cycle == 0) {\n        ttx = 1;\n        cycle = 1;\n    }\n    ;\n    baseTime = $bm_mod(ttx, $bm_div(1, cycle));\n    min = 0;\n    max = $bm_mul(360, r);\n    UP = linear(baseTime, 0, $bm_div(1, cycle), min, max);\n    Down = linear(baseTime, $bm_div(1, cycle), cycle, max, min);\n    $bm_rt = baseTime < $bm_div(1, cycle) ? $bm_sum($bm_sum($bm_sum(UP, value), rota), rotax) : $bm_sum($bm_sum($bm_sum(Down, value), rota), rotax);\n} else {\n    $bm_rt = $bm_sum($bm_sum(value, rota), rotax);\n}"},"ry":{"a":0,"k":0,"ix":9,"x":"var $bm_rt;\nvar no, lag, rotay, r, r, rota, cycle, gtime, nKey, gtime, gtime, decay, gtime, nKey, ttx, ttx, cycle, ttx, cycle, baseTime, min, max, UP, Down;\nno = 6;\nlag = $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Rotation XY'), 0.1);\nrotay = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('RotationY');\nif (thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('ReverseRotation') == 1) {\n    r = 1;\n} else {\n    r = -1;\n}\n;\n$bm_rt = rota = $bm_mul(lag[1], no);\nif (thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('AutoRotation_Y') == 1) {\n    cycle = $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Speed(XYZ)'), 0.01);\n    gtime = 0;\n    try {\n        nKey = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Decay(Scale)').nearestKey(0);\n        if (time >= nKey.time) {\n            gtime = $bm_sub(time, nKey.time);\n        } else {\n            gtime = $bm_sub(time, nKey.time);\n            if (gtime < 0) {\n                decay = 0;\n            }\n        }\n    } catch (e) {\n        gtime = time;\n        nKey = 'NaN';\n    }\n    ;\n    if (nKey == 'NaN') {\n        ttx = $bm_sub(time, thisLayer.inPoint);\n    } else {\n        ttx = gtime;\n    }\n    ;\n    cycle = $bm_mul(cycle, Math.exp($bm_mul($bm_mul(ttx, thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Decay(Scale)')), 0.01)));\n    if (cycle == 0) {\n        ttx = 1;\n        cycle = 1;\n    }\n    ;\n    baseTime = $bm_mod(ttx, $bm_div(1, cycle));\n    min = 0;\n    max = $bm_mul(360, r);\n    UP = linear(baseTime, 0, $bm_div(1, cycle), min, max);\n    Down = linear(baseTime, $bm_div(1, cycle), cycle, max, min);\n    $bm_rt = baseTime < $bm_div(1, cycle) ? $bm_sum($bm_sum($bm_sum(UP, value), rota), rotay) : $bm_sum($bm_sum($bm_sum(Down, value), rota), rotay);\n} else {\n    $bm_rt = $bm_sum($bm_sum(value, rota), rotay);\n}"},"rz":{"a":0,"k":0,"ix":10,"x":"var $bm_rt;\nvar no, lag, rotaz, r, r, rota, cycle, gtime, nKey, gtime, gtime, decay, gtime, nKey, ttx, ttx, cycle, ttx, cycle, baseTime, min, max, UP, Down;\nno = 6;\nlag = $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Rotation  Z'), 0.1);\nrotaz = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('RotationZ');\nif (thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('ReverseRotation') == 1) {\n    r = 1;\n} else {\n    r = -1;\n}\n;\n$bm_rt = rota = $bm_mul(lag, no);\nif (thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('AutoRotation_Z') == 1) {\n    cycle = $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Speed(XYZ)'), 0.01);\n    gtime = 0;\n    try {\n        nKey = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Decay(Scale)').nearestKey(0);\n        if (time >= nKey.time) {\n            gtime = $bm_sub(time, nKey.time);\n        } else {\n            gtime = $bm_sub(time, nKey.time);\n            if (gtime < 0) {\n                decay = 0;\n            }\n        }\n    } catch (e) {\n        gtime = time;\n        nKey = 'NaN';\n    }\n    ;\n    if (nKey == 'NaN') {\n        ttx = $bm_sub(time, thisLayer.inPoint);\n    } else {\n        ttx = gtime;\n    }\n    ;\n    cycle = $bm_mul(cycle, Math.exp($bm_mul($bm_mul(ttx, thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Decay(Scale)')), 0.01)));\n    if (cycle == 0) {\n        ttx = 1;\n        cycle = 1;\n    }\n    ;\n    baseTime = $bm_mod(ttx, $bm_div(1, cycle));\n    min = 0;\n    max = $bm_mul(360, r);\n    UP = linear(baseTime, 0, $bm_div(1, cycle), min, max);\n    Down = linear(baseTime, $bm_div(1, cycle), cycle, max, min);\n    $bm_rt = baseTime < $bm_div(1, cycle) ? $bm_sum($bm_sum($bm_sum(UP, value), rota), rotaz) : $bm_sum($bm_sum($bm_sum(Down, value), rota), rotaz);\n} else {\n    $bm_rt = $bm_sum($bm_sum(value, rota), rotaz);\n}"},"or":{"a":0,"k":[0,0,0],"ix":7,"x":"var $bm_rt;\nvar a, o, tr, tr, o, o, o;\na = [\n    0,\n    0,\n    0\n];\no = [\n    0,\n    0,\n    0\n];\ntry {\n    tr = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Target');\n} catch (e) {\n    tr = 0;\n}\nif (tr != 0) {\n    try {\n        if (this.parent) {\n            o = lookAt($bm_sum($bm_transform.position, this.parent.position), tr.position);\n        } else {\n            o = lookAt($bm_transform.position, tr.position);\n        }\n        ;\n    } catch (e) {\n        o = lookAt($bm_transform.position, tr.position);\n    }\n}\n;\nif (thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('FollowTarget_X') == 1) {\n    a[0] = o[0];\n}\nif (thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('FollowTarget_Y') == 1) {\n    a[1] = o[1];\n}\nif (thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('FollowTarget_Z') == 1) {\n    a[2] = o[2];\n}\n$bm_rt = $bm_sum(a, value);"},"p":{"a":0,"k":[10,10,0],"ix":2,"x":"var $bm_rt;\nvar huriko, bounceX, bounceY, bounceZ, rangexy, rangez, angle, offset, lag, lagren, lposxy, lposz, decay, displacementXYZ, splagXY, splagZ, gtime, nKey, gtime, gtime, decay, gtime, nKey, ttx, ttx, posxy, posz, stime, range, offset, lagx, lagy, lagz, offsetXY, offsetZ, offsetZ, decayspeed, displacementXYZ, rangexy, x, y, z, x, x, y, y, z, z;\nvar no = 6;\nhuriko = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Pendulum ON');\nbounceX = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Bounce_X');\nbounceY = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Bounce_Y');\nbounceZ = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Bounce_Z');\nrangexy = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Scale XY');\nrangez = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Scale  Z');\nangle = degreesToRadians($bm_sum(180, $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Angle(Pendulum only)'), -1)));\noffset = $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Offset'), 0.01);\nlag = $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Shift'), 0.01);\nlagren = $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Scale(xy)'), 0.1);\nlposxy = $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Position XY'), 0.1);\nlposz = $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Position  Z'), 0.1);\ndecay = $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Decay(Scale)'), 0.01);\ndisplacementXYZ = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM_speedXYZ[delete prohibited]')('ADBE Slider Control-0001');\nsplagXY = $bm_sum([\n    1,\n    1\n], $bm_mul($bm_mul(no, thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Speed XY')), 0.0001));\nsplagZ = $bm_sum(1, $bm_mul($bm_mul(no, thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Speed Z')), 0.0001));\ngtime = 0;\ntry {\n    nKey = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Decay(Scale)').nearestKey(0);\n    if (time >= nKey.time) {\n        gtime = $bm_sub(time, nKey.time);\n    } else {\n        gtime = $bm_sub(time, nKey.time);\n        if (gtime < 0) {\n            decay = 0;\n        }\n    }\n} catch (e) {\n    gtime = time;\n    nKey = 'NaN';\n}\n;\nif (nKey == 'NaN') {\n    ttx = $bm_sub(time, thisLayer.inPoint);\n} else {\n    ttx = gtime;\n}\n;\nposxy = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Position_XY');\nposz = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Position__Z');\nstime = 1;\nrange = 100;\noffset = $bm_sum(offset, $bm_mul(lag, no));\nlagx = $bm_mul(lposxy[0], no);\nlagy = $bm_mul(lposxy[1], no);\nlagz = $bm_mul(lposz, no);\noffsetXY = $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Offset_XY'), 0.001);\noffsetZ = $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Offset__Z'), 0.001);\noffsetXY[0] = $bm_sum(offset, $bm_mul(offsetXY[0], no));\noffsetXY[1] = $bm_sum(offset, $bm_mul(offsetXY[1], no));\noffsetZ = $bm_sum(offset, $bm_mul(offsetZ, no));\ndecayspeed = $bm_mul(Math.abs(decay), 0.2);\ndisplacementXYZ = $bm_mul(displacementXYZ, Math.exp($bm_mul(ttx, decayspeed)));\n$bm_rt = rangexy = $bm_sum(rangexy, [\n    $bm_mul(lagren, no),\n    $bm_mul(lagren, no)\n]);\nif (huriko == true) {\n    x = $bm_mul(Math.sin($bm_sum($bm_mul($bm_mul($bm_mul(splagXY[0], displacementXYZ), Math.PI), stime), offsetXY[0])), Math.exp($bm_mul(ttx, decay)));\n    y = $bm_mul(Math.sin($bm_sum($bm_mul($bm_mul($bm_mul(splagXY[1], displacementXYZ), Math.PI), stime), offsetXY[1])), Math.exp($bm_mul(ttx, decay)));\n    z = $bm_mul(Math.sin($bm_sum($bm_mul($bm_mul($bm_mul(splagZ, displacementXYZ), Math.PI), stime), offsetZ)), Math.exp($bm_mul(ttx, decay)));\n    try {\n        $bm_rt = [\n            rangexy[0] * Math.sin(x * (range * 0.01) + angle) + value[0] + posxy[0] + lagx,\n            rangexy[1] * Math.cos(y * (range * 0.01) + angle) + value[1] + posxy[1] + lagy,\n            rangez * Math.cos(z * (range * 0.01) + angle) + value[2] + posz + lagz\n        ];\n    } catch (e) {\n        $bm_rt = [\n            rangexy[0] * Math.sin(x * (range * 0.01) + angle) + value[0] + posxy[0] + lagx,\n            rangexy[1] * Math.cos(y * (range * 0.01) + angle) + value[1] + posxy[1] + lagy\n        ];\n    }\n} else {\n    x = $bm_mul($bm_mul(rangexy[0], Math.sin($bm_sum($bm_mul($bm_mul($bm_mul(splagXY[0], displacementXYZ), Math.PI), stime), offsetXY[0]))), Math.exp($bm_mul(ttx, decay)));\n    if (bounceX != false) {\n        x = Math.abs(x);\n    }\n    y = $bm_mul($bm_mul(rangexy[1], Math.cos($bm_sum($bm_mul($bm_mul($bm_mul(splagXY[1], displacementXYZ), Math.PI), stime), offsetXY[1]))), Math.exp($bm_mul(ttx, decay)));\n    if (bounceY != false) {\n        y = $bm_mul(Math.abs(y), -1);\n    }\n    z = $bm_mul($bm_mul(rangez, Math.cos($bm_sum($bm_mul($bm_mul($bm_mul(splagZ, displacementXYZ), Math.PI), stime), offsetZ))), Math.exp($bm_mul(ttx, decay)));\n    if (bounceZ != false) {\n        z = Math.abs(z);\n    }\n    try {\n        $bm_rt = [\n            x + value[0] + posxy[0] + lagx,\n            y + value[1] + posxy[1] + lagy,\n            z + value[2] + posz + lagz\n        ];\n    } catch (e) {\n        $bm_rt = [\n            x + value[0] + posxy[0] + lagx,\n            y + value[1] + posxy[1] + lagy\n        ];\n    }\n}"},"a":{"a":0,"k":[671.264,574,0],"ix":1,"x":"var $bm_rt;\nvar a, b;\na = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Anchorpoint_XY');\nb = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Anchorpoint__Z');\ntry {\n    $bm_rt = [\n        a[0] + value[0],\n        a[1] + value[1],\n        b + value[2]\n    ];\n} catch (e) {\n    $bm_rt = [\n        a[0] + value[0],\n        a[1] + value[1]\n    ];\n}"},"s":{"a":0,"k":[330,330,330],"ix":6,"x":"var $bm_rt;\nvar a, b;\na = $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Scale_XY(%)'), 0.01);\nb = $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Scale__Z'), 0.01);\ntry {\n    $bm_rt = [\n        a[0] * value[0],\n        a[1] * value[1],\n        b * value[2]\n    ];\n} catch (e) {\n    $bm_rt = [\n        a[0] * value[0],\n        a[1] * value[1]\n    ];\n}"}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[23.05,-12.73],[12.73,23.051],[-23.051,12.73],[-12.731,-23.051]],"o":[[23.05,12.73],[-12.731,23.051],[-23.051,-12.73],[12.73,-23.051]],"v":[[23.05,0],[-0.001,23.051],[-23.051,0],[-0.001,-23.051]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false,"_render":true},{"ty":"fl","c":{"a":0,"k":[0.1122,0.5685,0.9678,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false,"_render":true},{"ty":"tr","p":{"a":0,"k":[671.264,574],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform","_render":true}],"nm":"Group 1","np":2,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false,"_render":true}],"ip":0,"op":900.000036657751,"st":0,"bm":0,"completed":true},{"ddd":1,"ind":5,"ty":4,"nm":"          Layer 5 Outlines","parent":1,"sr":1,"ks":{"o":{"a":0,"k":100,"ix":11,"x":"var $bm_rt;\n$bm_rt = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Opacity(0~100)');"},"rx":{"a":0,"k":0,"ix":8,"x":"var $bm_rt;\nvar no, lag, rotax, r, r, rota, cycle, gtime, nKey, gtime, gtime, decay, gtime, nKey, ttx, ttx, cycle, ttx, cycle, baseTime, min, max, UP, Down;\nno = 5;\nlag = $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Rotation XY'), 0.1);\nrotax = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('RotationX');\nif (thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('ReverseRotation') == 1) {\n    r = 1;\n} else {\n    r = -1;\n}\n;\n$bm_rt = rota = $bm_mul(lag[0], no);\nif (thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('AutoRotation_X') == 1) {\n    cycle = $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Speed(XYZ)'), 0.01);\n    gtime = 0;\n    try {\n        nKey = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Decay(Scale)').nearestKey(0);\n        if (time >= nKey.time) {\n            gtime = $bm_sub(time, nKey.time);\n        } else {\n            gtime = $bm_sub(time, nKey.time);\n            if (gtime < 0) {\n                decay = 0;\n            }\n        }\n    } catch (e) {\n        gtime = time;\n        nKey = 'NaN';\n    }\n    ;\n    if (nKey == 'NaN') {\n        ttx = $bm_sub(time, thisLayer.inPoint);\n    } else {\n        ttx = gtime;\n    }\n    ;\n    cycle = $bm_mul(cycle, Math.exp($bm_mul($bm_mul(ttx, thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Decay(Scale)')), 0.01)));\n    if (cycle == 0) {\n        ttx = 1;\n        cycle = 1;\n    }\n    ;\n    baseTime = $bm_mod(ttx, $bm_div(1, cycle));\n    min = 0;\n    max = $bm_mul(360, r);\n    UP = linear(baseTime, 0, $bm_div(1, cycle), min, max);\n    Down = linear(baseTime, $bm_div(1, cycle), cycle, max, min);\n    $bm_rt = baseTime < $bm_div(1, cycle) ? $bm_sum($bm_sum($bm_sum(UP, value), rota), rotax) : $bm_sum($bm_sum($bm_sum(Down, value), rota), rotax);\n} else {\n    $bm_rt = $bm_sum($bm_sum(value, rota), rotax);\n}"},"ry":{"a":0,"k":0,"ix":9,"x":"var $bm_rt;\nvar no, lag, rotay, r, r, rota, cycle, gtime, nKey, gtime, gtime, decay, gtime, nKey, ttx, ttx, cycle, ttx, cycle, baseTime, min, max, UP, Down;\nno = 5;\nlag = $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Rotation XY'), 0.1);\nrotay = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('RotationY');\nif (thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('ReverseRotation') == 1) {\n    r = 1;\n} else {\n    r = -1;\n}\n;\n$bm_rt = rota = $bm_mul(lag[1], no);\nif (thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('AutoRotation_Y') == 1) {\n    cycle = $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Speed(XYZ)'), 0.01);\n    gtime = 0;\n    try {\n        nKey = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Decay(Scale)').nearestKey(0);\n        if (time >= nKey.time) {\n            gtime = $bm_sub(time, nKey.time);\n        } else {\n            gtime = $bm_sub(time, nKey.time);\n            if (gtime < 0) {\n                decay = 0;\n            }\n        }\n    } catch (e) {\n        gtime = time;\n        nKey = 'NaN';\n    }\n    ;\n    if (nKey == 'NaN') {\n        ttx = $bm_sub(time, thisLayer.inPoint);\n    } else {\n        ttx = gtime;\n    }\n    ;\n    cycle = $bm_mul(cycle, Math.exp($bm_mul($bm_mul(ttx, thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Decay(Scale)')), 0.01)));\n    if (cycle == 0) {\n        ttx = 1;\n        cycle = 1;\n    }\n    ;\n    baseTime = $bm_mod(ttx, $bm_div(1, cycle));\n    min = 0;\n    max = $bm_mul(360, r);\n    UP = linear(baseTime, 0, $bm_div(1, cycle), min, max);\n    Down = linear(baseTime, $bm_div(1, cycle), cycle, max, min);\n    $bm_rt = baseTime < $bm_div(1, cycle) ? $bm_sum($bm_sum($bm_sum(UP, value), rota), rotay) : $bm_sum($bm_sum($bm_sum(Down, value), rota), rotay);\n} else {\n    $bm_rt = $bm_sum($bm_sum(value, rota), rotay);\n}"},"rz":{"a":0,"k":0,"ix":10,"x":"var $bm_rt;\nvar no, lag, rotaz, r, r, rota, cycle, gtime, nKey, gtime, gtime, decay, gtime, nKey, ttx, ttx, cycle, ttx, cycle, baseTime, min, max, UP, Down;\nno = 5;\nlag = $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Rotation  Z'), 0.1);\nrotaz = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('RotationZ');\nif (thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('ReverseRotation') == 1) {\n    r = 1;\n} else {\n    r = -1;\n}\n;\n$bm_rt = rota = $bm_mul(lag, no);\nif (thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('AutoRotation_Z') == 1) {\n    cycle = $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Speed(XYZ)'), 0.01);\n    gtime = 0;\n    try {\n        nKey = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Decay(Scale)').nearestKey(0);\n        if (time >= nKey.time) {\n            gtime = $bm_sub(time, nKey.time);\n        } else {\n            gtime = $bm_sub(time, nKey.time);\n            if (gtime < 0) {\n                decay = 0;\n            }\n        }\n    } catch (e) {\n        gtime = time;\n        nKey = 'NaN';\n    }\n    ;\n    if (nKey == 'NaN') {\n        ttx = $bm_sub(time, thisLayer.inPoint);\n    } else {\n        ttx = gtime;\n    }\n    ;\n    cycle = $bm_mul(cycle, Math.exp($bm_mul($bm_mul(ttx, thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Decay(Scale)')), 0.01)));\n    if (cycle == 0) {\n        ttx = 1;\n        cycle = 1;\n    }\n    ;\n    baseTime = $bm_mod(ttx, $bm_div(1, cycle));\n    min = 0;\n    max = $bm_mul(360, r);\n    UP = linear(baseTime, 0, $bm_div(1, cycle), min, max);\n    Down = linear(baseTime, $bm_div(1, cycle), cycle, max, min);\n    $bm_rt = baseTime < $bm_div(1, cycle) ? $bm_sum($bm_sum($bm_sum(UP, value), rota), rotaz) : $bm_sum($bm_sum($bm_sum(Down, value), rota), rotaz);\n} else {\n    $bm_rt = $bm_sum($bm_sum(value, rota), rotaz);\n}"},"or":{"a":0,"k":[0,0,0],"ix":7,"x":"var $bm_rt;\nvar a, o, tr, tr, o, o, o;\na = [\n    0,\n    0,\n    0\n];\no = [\n    0,\n    0,\n    0\n];\ntry {\n    tr = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Target');\n} catch (e) {\n    tr = 0;\n}\nif (tr != 0) {\n    try {\n        if (this.parent) {\n            o = lookAt($bm_sum($bm_transform.position, this.parent.position), tr.position);\n        } else {\n            o = lookAt($bm_transform.position, tr.position);\n        }\n        ;\n    } catch (e) {\n        o = lookAt($bm_transform.position, tr.position);\n    }\n}\n;\nif (thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('FollowTarget_X') == 1) {\n    a[0] = o[0];\n}\nif (thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('FollowTarget_Y') == 1) {\n    a[1] = o[1];\n}\nif (thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('FollowTarget_Z') == 1) {\n    a[2] = o[2];\n}\n$bm_rt = $bm_sum(a, value);"},"p":{"a":0,"k":[10,10,0],"ix":2,"x":"var $bm_rt;\nvar huriko, bounceX, bounceY, bounceZ, rangexy, rangez, angle, offset, lag, lagren, lposxy, lposz, decay, displacementXYZ, splagXY, splagZ, gtime, nKey, gtime, gtime, decay, gtime, nKey, ttx, ttx, posxy, posz, stime, range, offset, lagx, lagy, lagz, offsetXY, offsetZ, offsetZ, decayspeed, displacementXYZ, rangexy, x, y, z, x, x, y, y, z, z;\nvar no = 5;\nhuriko = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Pendulum ON');\nbounceX = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Bounce_X');\nbounceY = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Bounce_Y');\nbounceZ = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Bounce_Z');\nrangexy = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Scale XY');\nrangez = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Scale  Z');\nangle = degreesToRadians($bm_sum(180, $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Angle(Pendulum only)'), -1)));\noffset = $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Offset'), 0.01);\nlag = $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Shift'), 0.01);\nlagren = $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Scale(xy)'), 0.1);\nlposxy = $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Position XY'), 0.1);\nlposz = $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Position  Z'), 0.1);\ndecay = $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Decay(Scale)'), 0.01);\ndisplacementXYZ = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM_speedXYZ[delete prohibited]')('ADBE Slider Control-0001');\nsplagXY = $bm_sum([\n    1,\n    1\n], $bm_mul($bm_mul(no, thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Speed XY')), 0.0001));\nsplagZ = $bm_sum(1, $bm_mul($bm_mul(no, thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Speed Z')), 0.0001));\ngtime = 0;\ntry {\n    nKey = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Decay(Scale)').nearestKey(0);\n    if (time >= nKey.time) {\n        gtime = $bm_sub(time, nKey.time);\n    } else {\n        gtime = $bm_sub(time, nKey.time);\n        if (gtime < 0) {\n            decay = 0;\n        }\n    }\n} catch (e) {\n    gtime = time;\n    nKey = 'NaN';\n}\n;\nif (nKey == 'NaN') {\n    ttx = $bm_sub(time, thisLayer.inPoint);\n} else {\n    ttx = gtime;\n}\n;\nposxy = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Position_XY');\nposz = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Position__Z');\nstime = 1;\nrange = 100;\noffset = $bm_sum(offset, $bm_mul(lag, no));\nlagx = $bm_mul(lposxy[0], no);\nlagy = $bm_mul(lposxy[1], no);\nlagz = $bm_mul(lposz, no);\noffsetXY = $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Offset_XY'), 0.001);\noffsetZ = $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Offset__Z'), 0.001);\noffsetXY[0] = $bm_sum(offset, $bm_mul(offsetXY[0], no));\noffsetXY[1] = $bm_sum(offset, $bm_mul(offsetXY[1], no));\noffsetZ = $bm_sum(offset, $bm_mul(offsetZ, no));\ndecayspeed = $bm_mul(Math.abs(decay), 0.2);\ndisplacementXYZ = $bm_mul(displacementXYZ, Math.exp($bm_mul(ttx, decayspeed)));\n$bm_rt = rangexy = $bm_sum(rangexy, [\n    $bm_mul(lagren, no),\n    $bm_mul(lagren, no)\n]);\nif (huriko == true) {\n    x = $bm_mul(Math.sin($bm_sum($bm_mul($bm_mul($bm_mul(splagXY[0], displacementXYZ), Math.PI), stime), offsetXY[0])), Math.exp($bm_mul(ttx, decay)));\n    y = $bm_mul(Math.sin($bm_sum($bm_mul($bm_mul($bm_mul(splagXY[1], displacementXYZ), Math.PI), stime), offsetXY[1])), Math.exp($bm_mul(ttx, decay)));\n    z = $bm_mul(Math.sin($bm_sum($bm_mul($bm_mul($bm_mul(splagZ, displacementXYZ), Math.PI), stime), offsetZ)), Math.exp($bm_mul(ttx, decay)));\n    try {\n        $bm_rt = [\n            rangexy[0] * Math.sin(x * (range * 0.01) + angle) + value[0] + posxy[0] + lagx,\n            rangexy[1] * Math.cos(y * (range * 0.01) + angle) + value[1] + posxy[1] + lagy,\n            rangez * Math.cos(z * (range * 0.01) + angle) + value[2] + posz + lagz\n        ];\n    } catch (e) {\n        $bm_rt = [\n            rangexy[0] * Math.sin(x * (range * 0.01) + angle) + value[0] + posxy[0] + lagx,\n            rangexy[1] * Math.cos(y * (range * 0.01) + angle) + value[1] + posxy[1] + lagy\n        ];\n    }\n} else {\n    x = $bm_mul($bm_mul(rangexy[0], Math.sin($bm_sum($bm_mul($bm_mul($bm_mul(splagXY[0], displacementXYZ), Math.PI), stime), offsetXY[0]))), Math.exp($bm_mul(ttx, decay)));\n    if (bounceX != false) {\n        x = Math.abs(x);\n    }\n    y = $bm_mul($bm_mul(rangexy[1], Math.cos($bm_sum($bm_mul($bm_mul($bm_mul(splagXY[1], displacementXYZ), Math.PI), stime), offsetXY[1]))), Math.exp($bm_mul(ttx, decay)));\n    if (bounceY != false) {\n        y = $bm_mul(Math.abs(y), -1);\n    }\n    z = $bm_mul($bm_mul(rangez, Math.cos($bm_sum($bm_mul($bm_mul($bm_mul(splagZ, displacementXYZ), Math.PI), stime), offsetZ))), Math.exp($bm_mul(ttx, decay)));\n    if (bounceZ != false) {\n        z = Math.abs(z);\n    }\n    try {\n        $bm_rt = [\n            x + value[0] + posxy[0] + lagx,\n            y + value[1] + posxy[1] + lagy,\n            z + value[2] + posz + lagz\n        ];\n    } catch (e) {\n        $bm_rt = [\n            x + value[0] + posxy[0] + lagx,\n            y + value[1] + posxy[1] + lagy\n        ];\n    }\n}"},"a":{"a":0,"k":[593.421,574,0],"ix":1,"x":"var $bm_rt;\nvar a, b;\na = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Anchorpoint_XY');\nb = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Anchorpoint__Z');\ntry {\n    $bm_rt = [\n        a[0] + value[0],\n        a[1] + value[1],\n        b + value[2]\n    ];\n} catch (e) {\n    $bm_rt = [\n        a[0] + value[0],\n        a[1] + value[1]\n    ];\n}"},"s":{"a":0,"k":[330,330,330],"ix":6,"x":"var $bm_rt;\nvar a, b;\na = $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Scale_XY(%)'), 0.01);\nb = $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Scale__Z'), 0.01);\ntry {\n    $bm_rt = [\n        a[0] * value[0],\n        a[1] * value[1],\n        b * value[2]\n    ];\n} catch (e) {\n    $bm_rt = [\n        a[0] * value[0],\n        a[1] * value[1]\n    ];\n}"}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[23.051,-12.73],[12.731,23.051],[-23.05,12.73],[-12.73,-23.051]],"o":[[23.051,12.73],[-12.73,23.051],[-23.05,-12.73],[12.731,-23.051]],"v":[[23.051,0],[0,23.051],[-23.05,0],[0,-23.051]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false,"_render":true},{"ty":"fl","c":{"a":0,"k":[0.851,0.8784,0.902,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false,"_render":true},{"ty":"tr","p":{"a":0,"k":[593.421,574],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform","_render":true}],"nm":"Group 1","np":2,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false,"_render":true}],"ip":0,"op":900.000036657751,"st":0,"bm":0,"completed":true},{"ddd":1,"ind":6,"ty":4,"nm":"          Layer 4 Outlines","parent":1,"sr":1,"ks":{"o":{"a":0,"k":100,"ix":11,"x":"var $bm_rt;\n$bm_rt = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Opacity(0~100)');"},"rx":{"a":0,"k":0,"ix":8,"x":"var $bm_rt;\nvar no, lag, rotax, r, r, rota, cycle, gtime, nKey, gtime, gtime, decay, gtime, nKey, ttx, ttx, cycle, ttx, cycle, baseTime, min, max, UP, Down;\nno = 4;\nlag = $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Rotation XY'), 0.1);\nrotax = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('RotationX');\nif (thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('ReverseRotation') == 1) {\n    r = 1;\n} else {\n    r = -1;\n}\n;\n$bm_rt = rota = $bm_mul(lag[0], no);\nif (thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('AutoRotation_X') == 1) {\n    cycle = $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Speed(XYZ)'), 0.01);\n    gtime = 0;\n    try {\n        nKey = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Decay(Scale)').nearestKey(0);\n        if (time >= nKey.time) {\n            gtime = $bm_sub(time, nKey.time);\n        } else {\n            gtime = $bm_sub(time, nKey.time);\n            if (gtime < 0) {\n                decay = 0;\n            }\n        }\n    } catch (e) {\n        gtime = time;\n        nKey = 'NaN';\n    }\n    ;\n    if (nKey == 'NaN') {\n        ttx = $bm_sub(time, thisLayer.inPoint);\n    } else {\n        ttx = gtime;\n    }\n    ;\n    cycle = $bm_mul(cycle, Math.exp($bm_mul($bm_mul(ttx, thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Decay(Scale)')), 0.01)));\n    if (cycle == 0) {\n        ttx = 1;\n        cycle = 1;\n    }\n    ;\n    baseTime = $bm_mod(ttx, $bm_div(1, cycle));\n    min = 0;\n    max = $bm_mul(360, r);\n    UP = linear(baseTime, 0, $bm_div(1, cycle), min, max);\n    Down = linear(baseTime, $bm_div(1, cycle), cycle, max, min);\n    $bm_rt = baseTime < $bm_div(1, cycle) ? $bm_sum($bm_sum($bm_sum(UP, value), rota), rotax) : $bm_sum($bm_sum($bm_sum(Down, value), rota), rotax);\n} else {\n    $bm_rt = $bm_sum($bm_sum(value, rota), rotax);\n}"},"ry":{"a":0,"k":0,"ix":9,"x":"var $bm_rt;\nvar no, lag, rotay, r, r, rota, cycle, gtime, nKey, gtime, gtime, decay, gtime, nKey, ttx, ttx, cycle, ttx, cycle, baseTime, min, max, UP, Down;\nno = 4;\nlag = $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Rotation XY'), 0.1);\nrotay = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('RotationY');\nif (thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('ReverseRotation') == 1) {\n    r = 1;\n} else {\n    r = -1;\n}\n;\n$bm_rt = rota = $bm_mul(lag[1], no);\nif (thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('AutoRotation_Y') == 1) {\n    cycle = $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Speed(XYZ)'), 0.01);\n    gtime = 0;\n    try {\n        nKey = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Decay(Scale)').nearestKey(0);\n        if (time >= nKey.time) {\n            gtime = $bm_sub(time, nKey.time);\n        } else {\n            gtime = $bm_sub(time, nKey.time);\n            if (gtime < 0) {\n                decay = 0;\n            }\n        }\n    } catch (e) {\n        gtime = time;\n        nKey = 'NaN';\n    }\n    ;\n    if (nKey == 'NaN') {\n        ttx = $bm_sub(time, thisLayer.inPoint);\n    } else {\n        ttx = gtime;\n    }\n    ;\n    cycle = $bm_mul(cycle, Math.exp($bm_mul($bm_mul(ttx, thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Decay(Scale)')), 0.01)));\n    if (cycle == 0) {\n        ttx = 1;\n        cycle = 1;\n    }\n    ;\n    baseTime = $bm_mod(ttx, $bm_div(1, cycle));\n    min = 0;\n    max = $bm_mul(360, r);\n    UP = linear(baseTime, 0, $bm_div(1, cycle), min, max);\n    Down = linear(baseTime, $bm_div(1, cycle), cycle, max, min);\n    $bm_rt = baseTime < $bm_div(1, cycle) ? $bm_sum($bm_sum($bm_sum(UP, value), rota), rotay) : $bm_sum($bm_sum($bm_sum(Down, value), rota), rotay);\n} else {\n    $bm_rt = $bm_sum($bm_sum(value, rota), rotay);\n}"},"rz":{"a":0,"k":0,"ix":10,"x":"var $bm_rt;\nvar no, lag, rotaz, r, r, rota, cycle, gtime, nKey, gtime, gtime, decay, gtime, nKey, ttx, ttx, cycle, ttx, cycle, baseTime, min, max, UP, Down;\nno = 4;\nlag = $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Rotation  Z'), 0.1);\nrotaz = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('RotationZ');\nif (thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('ReverseRotation') == 1) {\n    r = 1;\n} else {\n    r = -1;\n}\n;\n$bm_rt = rota = $bm_mul(lag, no);\nif (thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('AutoRotation_Z') == 1) {\n    cycle = $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Speed(XYZ)'), 0.01);\n    gtime = 0;\n    try {\n        nKey = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Decay(Scale)').nearestKey(0);\n        if (time >= nKey.time) {\n            gtime = $bm_sub(time, nKey.time);\n        } else {\n            gtime = $bm_sub(time, nKey.time);\n            if (gtime < 0) {\n                decay = 0;\n            }\n        }\n    } catch (e) {\n        gtime = time;\n        nKey = 'NaN';\n    }\n    ;\n    if (nKey == 'NaN') {\n        ttx = $bm_sub(time, thisLayer.inPoint);\n    } else {\n        ttx = gtime;\n    }\n    ;\n    cycle = $bm_mul(cycle, Math.exp($bm_mul($bm_mul(ttx, thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Decay(Scale)')), 0.01)));\n    if (cycle == 0) {\n        ttx = 1;\n        cycle = 1;\n    }\n    ;\n    baseTime = $bm_mod(ttx, $bm_div(1, cycle));\n    min = 0;\n    max = $bm_mul(360, r);\n    UP = linear(baseTime, 0, $bm_div(1, cycle), min, max);\n    Down = linear(baseTime, $bm_div(1, cycle), cycle, max, min);\n    $bm_rt = baseTime < $bm_div(1, cycle) ? $bm_sum($bm_sum($bm_sum(UP, value), rota), rotaz) : $bm_sum($bm_sum($bm_sum(Down, value), rota), rotaz);\n} else {\n    $bm_rt = $bm_sum($bm_sum(value, rota), rotaz);\n}"},"or":{"a":0,"k":[0,0,0],"ix":7,"x":"var $bm_rt;\nvar a, o, tr, tr, o, o, o;\na = [\n    0,\n    0,\n    0\n];\no = [\n    0,\n    0,\n    0\n];\ntry {\n    tr = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Target');\n} catch (e) {\n    tr = 0;\n}\nif (tr != 0) {\n    try {\n        if (this.parent) {\n            o = lookAt($bm_sum($bm_transform.position, this.parent.position), tr.position);\n        } else {\n            o = lookAt($bm_transform.position, tr.position);\n        }\n        ;\n    } catch (e) {\n        o = lookAt($bm_transform.position, tr.position);\n    }\n}\n;\nif (thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('FollowTarget_X') == 1) {\n    a[0] = o[0];\n}\nif (thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('FollowTarget_Y') == 1) {\n    a[1] = o[1];\n}\nif (thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('FollowTarget_Z') == 1) {\n    a[2] = o[2];\n}\n$bm_rt = $bm_sum(a, value);"},"p":{"a":0,"k":[10,10,0],"ix":2,"x":"var $bm_rt;\nvar huriko, bounceX, bounceY, bounceZ, rangexy, rangez, angle, offset, lag, lagren, lposxy, lposz, decay, displacementXYZ, splagXY, splagZ, gtime, nKey, gtime, gtime, decay, gtime, nKey, ttx, ttx, posxy, posz, stime, range, offset, lagx, lagy, lagz, offsetXY, offsetZ, offsetZ, decayspeed, displacementXYZ, rangexy, x, y, z, x, x, y, y, z, z;\nvar no = 4;\nhuriko = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Pendulum ON');\nbounceX = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Bounce_X');\nbounceY = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Bounce_Y');\nbounceZ = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Bounce_Z');\nrangexy = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Scale XY');\nrangez = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Scale  Z');\nangle = degreesToRadians($bm_sum(180, $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Angle(Pendulum only)'), -1)));\noffset = $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Offset'), 0.01);\nlag = $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Shift'), 0.01);\nlagren = $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Scale(xy)'), 0.1);\nlposxy = $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Position XY'), 0.1);\nlposz = $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Position  Z'), 0.1);\ndecay = $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Decay(Scale)'), 0.01);\ndisplacementXYZ = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM_speedXYZ[delete prohibited]')('ADBE Slider Control-0001');\nsplagXY = $bm_sum([\n    1,\n    1\n], $bm_mul($bm_mul(no, thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Speed XY')), 0.0001));\nsplagZ = $bm_sum(1, $bm_mul($bm_mul(no, thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Speed Z')), 0.0001));\ngtime = 0;\ntry {\n    nKey = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Decay(Scale)').nearestKey(0);\n    if (time >= nKey.time) {\n        gtime = $bm_sub(time, nKey.time);\n    } else {\n        gtime = $bm_sub(time, nKey.time);\n        if (gtime < 0) {\n            decay = 0;\n        }\n    }\n} catch (e) {\n    gtime = time;\n    nKey = 'NaN';\n}\n;\nif (nKey == 'NaN') {\n    ttx = $bm_sub(time, thisLayer.inPoint);\n} else {\n    ttx = gtime;\n}\n;\nposxy = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Position_XY');\nposz = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Position__Z');\nstime = 1;\nrange = 100;\noffset = $bm_sum(offset, $bm_mul(lag, no));\nlagx = $bm_mul(lposxy[0], no);\nlagy = $bm_mul(lposxy[1], no);\nlagz = $bm_mul(lposz, no);\noffsetXY = $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Offset_XY'), 0.001);\noffsetZ = $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Offset__Z'), 0.001);\noffsetXY[0] = $bm_sum(offset, $bm_mul(offsetXY[0], no));\noffsetXY[1] = $bm_sum(offset, $bm_mul(offsetXY[1], no));\noffsetZ = $bm_sum(offset, $bm_mul(offsetZ, no));\ndecayspeed = $bm_mul(Math.abs(decay), 0.2);\ndisplacementXYZ = $bm_mul(displacementXYZ, Math.exp($bm_mul(ttx, decayspeed)));\n$bm_rt = rangexy = $bm_sum(rangexy, [\n    $bm_mul(lagren, no),\n    $bm_mul(lagren, no)\n]);\nif (huriko == true) {\n    x = $bm_mul(Math.sin($bm_sum($bm_mul($bm_mul($bm_mul(splagXY[0], displacementXYZ), Math.PI), stime), offsetXY[0])), Math.exp($bm_mul(ttx, decay)));\n    y = $bm_mul(Math.sin($bm_sum($bm_mul($bm_mul($bm_mul(splagXY[1], displacementXYZ), Math.PI), stime), offsetXY[1])), Math.exp($bm_mul(ttx, decay)));\n    z = $bm_mul(Math.sin($bm_sum($bm_mul($bm_mul($bm_mul(splagZ, displacementXYZ), Math.PI), stime), offsetZ)), Math.exp($bm_mul(ttx, decay)));\n    try {\n        $bm_rt = [\n            rangexy[0] * Math.sin(x * (range * 0.01) + angle) + value[0] + posxy[0] + lagx,\n            rangexy[1] * Math.cos(y * (range * 0.01) + angle) + value[1] + posxy[1] + lagy,\n            rangez * Math.cos(z * (range * 0.01) + angle) + value[2] + posz + lagz\n        ];\n    } catch (e) {\n        $bm_rt = [\n            rangexy[0] * Math.sin(x * (range * 0.01) + angle) + value[0] + posxy[0] + lagx,\n            rangexy[1] * Math.cos(y * (range * 0.01) + angle) + value[1] + posxy[1] + lagy\n        ];\n    }\n} else {\n    x = $bm_mul($bm_mul(rangexy[0], Math.sin($bm_sum($bm_mul($bm_mul($bm_mul(splagXY[0], displacementXYZ), Math.PI), stime), offsetXY[0]))), Math.exp($bm_mul(ttx, decay)));\n    if (bounceX != false) {\n        x = Math.abs(x);\n    }\n    y = $bm_mul($bm_mul(rangexy[1], Math.cos($bm_sum($bm_mul($bm_mul($bm_mul(splagXY[1], displacementXYZ), Math.PI), stime), offsetXY[1]))), Math.exp($bm_mul(ttx, decay)));\n    if (bounceY != false) {\n        y = $bm_mul(Math.abs(y), -1);\n    }\n    z = $bm_mul($bm_mul(rangez, Math.cos($bm_sum($bm_mul($bm_mul($bm_mul(splagZ, displacementXYZ), Math.PI), stime), offsetZ))), Math.exp($bm_mul(ttx, decay)));\n    if (bounceZ != false) {\n        z = Math.abs(z);\n    }\n    try {\n        $bm_rt = [\n            x + value[0] + posxy[0] + lagx,\n            y + value[1] + posxy[1] + lagy,\n            z + value[2] + posz + lagz\n        ];\n    } catch (e) {\n        $bm_rt = [\n            x + value[0] + posxy[0] + lagx,\n            y + value[1] + posxy[1] + lagy\n        ];\n    }\n}"},"a":{"a":0,"k":[515.579,574,0],"ix":1,"x":"var $bm_rt;\nvar a, b;\na = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Anchorpoint_XY');\nb = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Anchorpoint__Z');\ntry {\n    $bm_rt = [\n        a[0] + value[0],\n        a[1] + value[1],\n        b + value[2]\n    ];\n} catch (e) {\n    $bm_rt = [\n        a[0] + value[0],\n        a[1] + value[1]\n    ];\n}"},"s":{"a":0,"k":[330,330,330],"ix":6,"x":"var $bm_rt;\nvar a, b;\na = $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Scale_XY(%)'), 0.01);\nb = $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Scale__Z'), 0.01);\ntry {\n    $bm_rt = [\n        a[0] * value[0],\n        a[1] * value[1],\n        b * value[2]\n    ];\n} catch (e) {\n    $bm_rt = [\n        a[0] * value[0],\n        a[1] * value[1]\n    ];\n}"}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[23.051,-12.73],[12.731,23.051],[-23.05,12.73],[-12.73,-23.051]],"o":[[23.051,12.73],[-12.73,23.051],[-23.05,-12.73],[12.731,-23.051]],"v":[[23.051,0],[0,23.051],[-23.05,0],[0,-23.051]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false,"_render":true},{"ty":"fl","c":{"a":0,"k":[0.1255,0.1529,0.1725,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false,"_render":true},{"ty":"tr","p":{"a":0,"k":[515.579,574],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform","_render":true}],"nm":"Group 1","np":2,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false,"_render":true}],"ip":0,"op":900.000036657751,"st":0,"bm":0,"completed":true},{"ddd":1,"ind":7,"ty":4,"nm":"          Layer 3 Outlines","parent":1,"sr":1,"ks":{"o":{"a":0,"k":100,"ix":11,"x":"var $bm_rt;\n$bm_rt = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Opacity(0~100)');"},"rx":{"a":0,"k":0,"ix":8,"x":"var $bm_rt;\nvar no, lag, rotax, r, r, rota, cycle, gtime, nKey, gtime, gtime, decay, gtime, nKey, ttx, ttx, cycle, ttx, cycle, baseTime, min, max, UP, Down;\nno = 3;\nlag = $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Rotation XY'), 0.1);\nrotax = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('RotationX');\nif (thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('ReverseRotation') == 1) {\n    r = 1;\n} else {\n    r = -1;\n}\n;\n$bm_rt = rota = $bm_mul(lag[0], no);\nif (thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('AutoRotation_X') == 1) {\n    cycle = $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Speed(XYZ)'), 0.01);\n    gtime = 0;\n    try {\n        nKey = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Decay(Scale)').nearestKey(0);\n        if (time >= nKey.time) {\n            gtime = $bm_sub(time, nKey.time);\n        } else {\n            gtime = $bm_sub(time, nKey.time);\n            if (gtime < 0) {\n                decay = 0;\n            }\n        }\n    } catch (e) {\n        gtime = time;\n        nKey = 'NaN';\n    }\n    ;\n    if (nKey == 'NaN') {\n        ttx = $bm_sub(time, thisLayer.inPoint);\n    } else {\n        ttx = gtime;\n    }\n    ;\n    cycle = $bm_mul(cycle, Math.exp($bm_mul($bm_mul(ttx, thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Decay(Scale)')), 0.01)));\n    if (cycle == 0) {\n        ttx = 1;\n        cycle = 1;\n    }\n    ;\n    baseTime = $bm_mod(ttx, $bm_div(1, cycle));\n    min = 0;\n    max = $bm_mul(360, r);\n    UP = linear(baseTime, 0, $bm_div(1, cycle), min, max);\n    Down = linear(baseTime, $bm_div(1, cycle), cycle, max, min);\n    $bm_rt = baseTime < $bm_div(1, cycle) ? $bm_sum($bm_sum($bm_sum(UP, value), rota), rotax) : $bm_sum($bm_sum($bm_sum(Down, value), rota), rotax);\n} else {\n    $bm_rt = $bm_sum($bm_sum(value, rota), rotax);\n}"},"ry":{"a":0,"k":0,"ix":9,"x":"var $bm_rt;\nvar no, lag, rotay, r, r, rota, cycle, gtime, nKey, gtime, gtime, decay, gtime, nKey, ttx, ttx, cycle, ttx, cycle, baseTime, min, max, UP, Down;\nno = 3;\nlag = $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Rotation XY'), 0.1);\nrotay = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('RotationY');\nif (thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('ReverseRotation') == 1) {\n    r = 1;\n} else {\n    r = -1;\n}\n;\n$bm_rt = rota = $bm_mul(lag[1], no);\nif (thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('AutoRotation_Y') == 1) {\n    cycle = $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Speed(XYZ)'), 0.01);\n    gtime = 0;\n    try {\n        nKey = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Decay(Scale)').nearestKey(0);\n        if (time >= nKey.time) {\n            gtime = $bm_sub(time, nKey.time);\n        } else {\n            gtime = $bm_sub(time, nKey.time);\n            if (gtime < 0) {\n                decay = 0;\n            }\n        }\n    } catch (e) {\n        gtime = time;\n        nKey = 'NaN';\n    }\n    ;\n    if (nKey == 'NaN') {\n        ttx = $bm_sub(time, thisLayer.inPoint);\n    } else {\n        ttx = gtime;\n    }\n    ;\n    cycle = $bm_mul(cycle, Math.exp($bm_mul($bm_mul(ttx, thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Decay(Scale)')), 0.01)));\n    if (cycle == 0) {\n        ttx = 1;\n        cycle = 1;\n    }\n    ;\n    baseTime = $bm_mod(ttx, $bm_div(1, cycle));\n    min = 0;\n    max = $bm_mul(360, r);\n    UP = linear(baseTime, 0, $bm_div(1, cycle), min, max);\n    Down = linear(baseTime, $bm_div(1, cycle), cycle, max, min);\n    $bm_rt = baseTime < $bm_div(1, cycle) ? $bm_sum($bm_sum($bm_sum(UP, value), rota), rotay) : $bm_sum($bm_sum($bm_sum(Down, value), rota), rotay);\n} else {\n    $bm_rt = $bm_sum($bm_sum(value, rota), rotay);\n}"},"rz":{"a":0,"k":0,"ix":10,"x":"var $bm_rt;\nvar no, lag, rotaz, r, r, rota, cycle, gtime, nKey, gtime, gtime, decay, gtime, nKey, ttx, ttx, cycle, ttx, cycle, baseTime, min, max, UP, Down;\nno = 3;\nlag = $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Rotation  Z'), 0.1);\nrotaz = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('RotationZ');\nif (thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('ReverseRotation') == 1) {\n    r = 1;\n} else {\n    r = -1;\n}\n;\n$bm_rt = rota = $bm_mul(lag, no);\nif (thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('AutoRotation_Z') == 1) {\n    cycle = $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Speed(XYZ)'), 0.01);\n    gtime = 0;\n    try {\n        nKey = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Decay(Scale)').nearestKey(0);\n        if (time >= nKey.time) {\n            gtime = $bm_sub(time, nKey.time);\n        } else {\n            gtime = $bm_sub(time, nKey.time);\n            if (gtime < 0) {\n                decay = 0;\n            }\n        }\n    } catch (e) {\n        gtime = time;\n        nKey = 'NaN';\n    }\n    ;\n    if (nKey == 'NaN') {\n        ttx = $bm_sub(time, thisLayer.inPoint);\n    } else {\n        ttx = gtime;\n    }\n    ;\n    cycle = $bm_mul(cycle, Math.exp($bm_mul($bm_mul(ttx, thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Decay(Scale)')), 0.01)));\n    if (cycle == 0) {\n        ttx = 1;\n        cycle = 1;\n    }\n    ;\n    baseTime = $bm_mod(ttx, $bm_div(1, cycle));\n    min = 0;\n    max = $bm_mul(360, r);\n    UP = linear(baseTime, 0, $bm_div(1, cycle), min, max);\n    Down = linear(baseTime, $bm_div(1, cycle), cycle, max, min);\n    $bm_rt = baseTime < $bm_div(1, cycle) ? $bm_sum($bm_sum($bm_sum(UP, value), rota), rotaz) : $bm_sum($bm_sum($bm_sum(Down, value), rota), rotaz);\n} else {\n    $bm_rt = $bm_sum($bm_sum(value, rota), rotaz);\n}"},"or":{"a":0,"k":[0,0,0],"ix":7,"x":"var $bm_rt;\nvar a, o, tr, tr, o, o, o;\na = [\n    0,\n    0,\n    0\n];\no = [\n    0,\n    0,\n    0\n];\ntry {\n    tr = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Target');\n} catch (e) {\n    tr = 0;\n}\nif (tr != 0) {\n    try {\n        if (this.parent) {\n            o = lookAt($bm_sum($bm_transform.position, this.parent.position), tr.position);\n        } else {\n            o = lookAt($bm_transform.position, tr.position);\n        }\n        ;\n    } catch (e) {\n        o = lookAt($bm_transform.position, tr.position);\n    }\n}\n;\nif (thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('FollowTarget_X') == 1) {\n    a[0] = o[0];\n}\nif (thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('FollowTarget_Y') == 1) {\n    a[1] = o[1];\n}\nif (thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('FollowTarget_Z') == 1) {\n    a[2] = o[2];\n}\n$bm_rt = $bm_sum(a, value);"},"p":{"a":0,"k":[10,10,0],"ix":2,"x":"var $bm_rt;\nvar huriko, bounceX, bounceY, bounceZ, rangexy, rangez, angle, offset, lag, lagren, lposxy, lposz, decay, displacementXYZ, splagXY, splagZ, gtime, nKey, gtime, gtime, decay, gtime, nKey, ttx, ttx, posxy, posz, stime, range, offset, lagx, lagy, lagz, offsetXY, offsetZ, offsetZ, decayspeed, displacementXYZ, rangexy, x, y, z, x, x, y, y, z, z;\nvar no = 3;\nhuriko = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Pendulum ON');\nbounceX = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Bounce_X');\nbounceY = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Bounce_Y');\nbounceZ = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Bounce_Z');\nrangexy = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Scale XY');\nrangez = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Scale  Z');\nangle = degreesToRadians($bm_sum(180, $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Angle(Pendulum only)'), -1)));\noffset = $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Offset'), 0.01);\nlag = $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Shift'), 0.01);\nlagren = $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Scale(xy)'), 0.1);\nlposxy = $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Position XY'), 0.1);\nlposz = $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Position  Z'), 0.1);\ndecay = $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Decay(Scale)'), 0.01);\ndisplacementXYZ = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM_speedXYZ[delete prohibited]')('ADBE Slider Control-0001');\nsplagXY = $bm_sum([\n    1,\n    1\n], $bm_mul($bm_mul(no, thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Speed XY')), 0.0001));\nsplagZ = $bm_sum(1, $bm_mul($bm_mul(no, thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Speed Z')), 0.0001));\ngtime = 0;\ntry {\n    nKey = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Decay(Scale)').nearestKey(0);\n    if (time >= nKey.time) {\n        gtime = $bm_sub(time, nKey.time);\n    } else {\n        gtime = $bm_sub(time, nKey.time);\n        if (gtime < 0) {\n            decay = 0;\n        }\n    }\n} catch (e) {\n    gtime = time;\n    nKey = 'NaN';\n}\n;\nif (nKey == 'NaN') {\n    ttx = $bm_sub(time, thisLayer.inPoint);\n} else {\n    ttx = gtime;\n}\n;\nposxy = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Position_XY');\nposz = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Position__Z');\nstime = 1;\nrange = 100;\noffset = $bm_sum(offset, $bm_mul(lag, no));\nlagx = $bm_mul(lposxy[0], no);\nlagy = $bm_mul(lposxy[1], no);\nlagz = $bm_mul(lposz, no);\noffsetXY = $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Offset_XY'), 0.001);\noffsetZ = $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Offset__Z'), 0.001);\noffsetXY[0] = $bm_sum(offset, $bm_mul(offsetXY[0], no));\noffsetXY[1] = $bm_sum(offset, $bm_mul(offsetXY[1], no));\noffsetZ = $bm_sum(offset, $bm_mul(offsetZ, no));\ndecayspeed = $bm_mul(Math.abs(decay), 0.2);\ndisplacementXYZ = $bm_mul(displacementXYZ, Math.exp($bm_mul(ttx, decayspeed)));\n$bm_rt = rangexy = $bm_sum(rangexy, [\n    $bm_mul(lagren, no),\n    $bm_mul(lagren, no)\n]);\nif (huriko == true) {\n    x = $bm_mul(Math.sin($bm_sum($bm_mul($bm_mul($bm_mul(splagXY[0], displacementXYZ), Math.PI), stime), offsetXY[0])), Math.exp($bm_mul(ttx, decay)));\n    y = $bm_mul(Math.sin($bm_sum($bm_mul($bm_mul($bm_mul(splagXY[1], displacementXYZ), Math.PI), stime), offsetXY[1])), Math.exp($bm_mul(ttx, decay)));\n    z = $bm_mul(Math.sin($bm_sum($bm_mul($bm_mul($bm_mul(splagZ, displacementXYZ), Math.PI), stime), offsetZ)), Math.exp($bm_mul(ttx, decay)));\n    try {\n        $bm_rt = [\n            rangexy[0] * Math.sin(x * (range * 0.01) + angle) + value[0] + posxy[0] + lagx,\n            rangexy[1] * Math.cos(y * (range * 0.01) + angle) + value[1] + posxy[1] + lagy,\n            rangez * Math.cos(z * (range * 0.01) + angle) + value[2] + posz + lagz\n        ];\n    } catch (e) {\n        $bm_rt = [\n            rangexy[0] * Math.sin(x * (range * 0.01) + angle) + value[0] + posxy[0] + lagx,\n            rangexy[1] * Math.cos(y * (range * 0.01) + angle) + value[1] + posxy[1] + lagy\n        ];\n    }\n} else {\n    x = $bm_mul($bm_mul(rangexy[0], Math.sin($bm_sum($bm_mul($bm_mul($bm_mul(splagXY[0], displacementXYZ), Math.PI), stime), offsetXY[0]))), Math.exp($bm_mul(ttx, decay)));\n    if (bounceX != false) {\n        x = Math.abs(x);\n    }\n    y = $bm_mul($bm_mul(rangexy[1], Math.cos($bm_sum($bm_mul($bm_mul($bm_mul(splagXY[1], displacementXYZ), Math.PI), stime), offsetXY[1]))), Math.exp($bm_mul(ttx, decay)));\n    if (bounceY != false) {\n        y = $bm_mul(Math.abs(y), -1);\n    }\n    z = $bm_mul($bm_mul(rangez, Math.cos($bm_sum($bm_mul($bm_mul($bm_mul(splagZ, displacementXYZ), Math.PI), stime), offsetZ))), Math.exp($bm_mul(ttx, decay)));\n    if (bounceZ != false) {\n        z = Math.abs(z);\n    }\n    try {\n        $bm_rt = [\n            x + value[0] + posxy[0] + lagx,\n            y + value[1] + posxy[1] + lagy,\n            z + value[2] + posz + lagz\n        ];\n    } catch (e) {\n        $bm_rt = [\n            x + value[0] + posxy[0] + lagx,\n            y + value[1] + posxy[1] + lagy\n        ];\n    }\n}"},"a":{"a":0,"k":[437.736,574,0],"ix":1,"x":"var $bm_rt;\nvar a, b;\na = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Anchorpoint_XY');\nb = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Anchorpoint__Z');\ntry {\n    $bm_rt = [\n        a[0] + value[0],\n        a[1] + value[1],\n        b + value[2]\n    ];\n} catch (e) {\n    $bm_rt = [\n        a[0] + value[0],\n        a[1] + value[1]\n    ];\n}"},"s":{"a":0,"k":[330,330,330],"ix":6,"x":"var $bm_rt;\nvar a, b;\na = $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Scale_XY(%)'), 0.01);\nb = $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Scale__Z'), 0.01);\ntry {\n    $bm_rt = [\n        a[0] * value[0],\n        a[1] * value[1],\n        b * value[2]\n    ];\n} catch (e) {\n    $bm_rt = [\n        a[0] * value[0],\n        a[1] * value[1]\n    ];\n}"}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[23.051,-12.73],[12.73,23.051],[-23.051,12.73],[-12.731,-23.051]],"o":[[23.051,12.73],[-12.731,23.051],[-23.051,-12.73],[12.73,-23.051]],"v":[[23.051,0],[-0.001,23.051],[-23.051,0],[-0.001,-23.051]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false,"_render":true},{"ty":"fl","c":{"a":0,"k":[0.112,0.588,0.928,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false,"_render":true},{"ty":"tr","p":{"a":0,"k":[437.736,574],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform","_render":true}],"nm":"Group 1","np":2,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false,"_render":true}],"ip":0,"op":900.000036657751,"st":0,"bm":0,"completed":true},{"ddd":1,"ind":8,"ty":4,"nm":"          Layer 2 Outlines","parent":1,"sr":1,"ks":{"o":{"a":0,"k":100,"ix":11,"x":"var $bm_rt;\n$bm_rt = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Opacity(0~100)');"},"rx":{"a":0,"k":0,"ix":8,"x":"var $bm_rt;\nvar no, lag, rotax, r, r, rota, cycle, gtime, nKey, gtime, gtime, decay, gtime, nKey, ttx, ttx, cycle, ttx, cycle, baseTime, min, max, UP, Down;\nno = 2;\nlag = $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Rotation XY'), 0.1);\nrotax = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('RotationX');\nif (thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('ReverseRotation') == 1) {\n    r = 1;\n} else {\n    r = -1;\n}\n;\n$bm_rt = rota = $bm_mul(lag[0], no);\nif (thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('AutoRotation_X') == 1) {\n    cycle = $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Speed(XYZ)'), 0.01);\n    gtime = 0;\n    try {\n        nKey = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Decay(Scale)').nearestKey(0);\n        if (time >= nKey.time) {\n            gtime = $bm_sub(time, nKey.time);\n        } else {\n            gtime = $bm_sub(time, nKey.time);\n            if (gtime < 0) {\n                decay = 0;\n            }\n        }\n    } catch (e) {\n        gtime = time;\n        nKey = 'NaN';\n    }\n    ;\n    if (nKey == 'NaN') {\n        ttx = $bm_sub(time, thisLayer.inPoint);\n    } else {\n        ttx = gtime;\n    }\n    ;\n    cycle = $bm_mul(cycle, Math.exp($bm_mul($bm_mul(ttx, thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Decay(Scale)')), 0.01)));\n    if (cycle == 0) {\n        ttx = 1;\n        cycle = 1;\n    }\n    ;\n    baseTime = $bm_mod(ttx, $bm_div(1, cycle));\n    min = 0;\n    max = $bm_mul(360, r);\n    UP = linear(baseTime, 0, $bm_div(1, cycle), min, max);\n    Down = linear(baseTime, $bm_div(1, cycle), cycle, max, min);\n    $bm_rt = baseTime < $bm_div(1, cycle) ? $bm_sum($bm_sum($bm_sum(UP, value), rota), rotax) : $bm_sum($bm_sum($bm_sum(Down, value), rota), rotax);\n} else {\n    $bm_rt = $bm_sum($bm_sum(value, rota), rotax);\n}"},"ry":{"a":0,"k":0,"ix":9,"x":"var $bm_rt;\nvar no, lag, rotay, r, r, rota, cycle, gtime, nKey, gtime, gtime, decay, gtime, nKey, ttx, ttx, cycle, ttx, cycle, baseTime, min, max, UP, Down;\nno = 2;\nlag = $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Rotation XY'), 0.1);\nrotay = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('RotationY');\nif (thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('ReverseRotation') == 1) {\n    r = 1;\n} else {\n    r = -1;\n}\n;\n$bm_rt = rota = $bm_mul(lag[1], no);\nif (thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('AutoRotation_Y') == 1) {\n    cycle = $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Speed(XYZ)'), 0.01);\n    gtime = 0;\n    try {\n        nKey = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Decay(Scale)').nearestKey(0);\n        if (time >= nKey.time) {\n            gtime = $bm_sub(time, nKey.time);\n        } else {\n            gtime = $bm_sub(time, nKey.time);\n            if (gtime < 0) {\n                decay = 0;\n            }\n        }\n    } catch (e) {\n        gtime = time;\n        nKey = 'NaN';\n    }\n    ;\n    if (nKey == 'NaN') {\n        ttx = $bm_sub(time, thisLayer.inPoint);\n    } else {\n        ttx = gtime;\n    }\n    ;\n    cycle = $bm_mul(cycle, Math.exp($bm_mul($bm_mul(ttx, thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Decay(Scale)')), 0.01)));\n    if (cycle == 0) {\n        ttx = 1;\n        cycle = 1;\n    }\n    ;\n    baseTime = $bm_mod(ttx, $bm_div(1, cycle));\n    min = 0;\n    max = $bm_mul(360, r);\n    UP = linear(baseTime, 0, $bm_div(1, cycle), min, max);\n    Down = linear(baseTime, $bm_div(1, cycle), cycle, max, min);\n    $bm_rt = baseTime < $bm_div(1, cycle) ? $bm_sum($bm_sum($bm_sum(UP, value), rota), rotay) : $bm_sum($bm_sum($bm_sum(Down, value), rota), rotay);\n} else {\n    $bm_rt = $bm_sum($bm_sum(value, rota), rotay);\n}"},"rz":{"a":0,"k":0,"ix":10,"x":"var $bm_rt;\nvar no, lag, rotaz, r, r, rota, cycle, gtime, nKey, gtime, gtime, decay, gtime, nKey, ttx, ttx, cycle, ttx, cycle, baseTime, min, max, UP, Down;\nno = 2;\nlag = $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Rotation  Z'), 0.1);\nrotaz = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('RotationZ');\nif (thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('ReverseRotation') == 1) {\n    r = 1;\n} else {\n    r = -1;\n}\n;\n$bm_rt = rota = $bm_mul(lag, no);\nif (thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('AutoRotation_Z') == 1) {\n    cycle = $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Speed(XYZ)'), 0.01);\n    gtime = 0;\n    try {\n        nKey = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Decay(Scale)').nearestKey(0);\n        if (time >= nKey.time) {\n            gtime = $bm_sub(time, nKey.time);\n        } else {\n            gtime = $bm_sub(time, nKey.time);\n            if (gtime < 0) {\n                decay = 0;\n            }\n        }\n    } catch (e) {\n        gtime = time;\n        nKey = 'NaN';\n    }\n    ;\n    if (nKey == 'NaN') {\n        ttx = $bm_sub(time, thisLayer.inPoint);\n    } else {\n        ttx = gtime;\n    }\n    ;\n    cycle = $bm_mul(cycle, Math.exp($bm_mul($bm_mul(ttx, thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Decay(Scale)')), 0.01)));\n    if (cycle == 0) {\n        ttx = 1;\n        cycle = 1;\n    }\n    ;\n    baseTime = $bm_mod(ttx, $bm_div(1, cycle));\n    min = 0;\n    max = $bm_mul(360, r);\n    UP = linear(baseTime, 0, $bm_div(1, cycle), min, max);\n    Down = linear(baseTime, $bm_div(1, cycle), cycle, max, min);\n    $bm_rt = baseTime < $bm_div(1, cycle) ? $bm_sum($bm_sum($bm_sum(UP, value), rota), rotaz) : $bm_sum($bm_sum($bm_sum(Down, value), rota), rotaz);\n} else {\n    $bm_rt = $bm_sum($bm_sum(value, rota), rotaz);\n}"},"or":{"a":0,"k":[0,0,0],"ix":7,"x":"var $bm_rt;\nvar a, o, tr, tr, o, o, o;\na = [\n    0,\n    0,\n    0\n];\no = [\n    0,\n    0,\n    0\n];\ntry {\n    tr = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Target');\n} catch (e) {\n    tr = 0;\n}\nif (tr != 0) {\n    try {\n        if (this.parent) {\n            o = lookAt($bm_sum($bm_transform.position, this.parent.position), tr.position);\n        } else {\n            o = lookAt($bm_transform.position, tr.position);\n        }\n        ;\n    } catch (e) {\n        o = lookAt($bm_transform.position, tr.position);\n    }\n}\n;\nif (thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('FollowTarget_X') == 1) {\n    a[0] = o[0];\n}\nif (thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('FollowTarget_Y') == 1) {\n    a[1] = o[1];\n}\nif (thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('FollowTarget_Z') == 1) {\n    a[2] = o[2];\n}\n$bm_rt = $bm_sum(a, value);"},"p":{"a":0,"k":[10,10,0],"ix":2,"x":"var $bm_rt;\nvar huriko, bounceX, bounceY, bounceZ, rangexy, rangez, angle, offset, lag, lagren, lposxy, lposz, decay, displacementXYZ, splagXY, splagZ, gtime, nKey, gtime, gtime, decay, gtime, nKey, ttx, ttx, posxy, posz, stime, range, offset, lagx, lagy, lagz, offsetXY, offsetZ, offsetZ, decayspeed, displacementXYZ, rangexy, x, y, z, x, x, y, y, z, z;\nvar no = 2;\nhuriko = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Pendulum ON');\nbounceX = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Bounce_X');\nbounceY = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Bounce_Y');\nbounceZ = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Bounce_Z');\nrangexy = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Scale XY');\nrangez = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Scale  Z');\nangle = degreesToRadians($bm_sum(180, $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Angle(Pendulum only)'), -1)));\noffset = $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Offset'), 0.01);\nlag = $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Shift'), 0.01);\nlagren = $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Scale(xy)'), 0.1);\nlposxy = $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Position XY'), 0.1);\nlposz = $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Position  Z'), 0.1);\ndecay = $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Decay(Scale)'), 0.01);\ndisplacementXYZ = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM_speedXYZ[delete prohibited]')('ADBE Slider Control-0001');\nsplagXY = $bm_sum([\n    1,\n    1\n], $bm_mul($bm_mul(no, thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Speed XY')), 0.0001));\nsplagZ = $bm_sum(1, $bm_mul($bm_mul(no, thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Speed Z')), 0.0001));\ngtime = 0;\ntry {\n    nKey = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Decay(Scale)').nearestKey(0);\n    if (time >= nKey.time) {\n        gtime = $bm_sub(time, nKey.time);\n    } else {\n        gtime = $bm_sub(time, nKey.time);\n        if (gtime < 0) {\n            decay = 0;\n        }\n    }\n} catch (e) {\n    gtime = time;\n    nKey = 'NaN';\n}\n;\nif (nKey == 'NaN') {\n    ttx = $bm_sub(time, thisLayer.inPoint);\n} else {\n    ttx = gtime;\n}\n;\nposxy = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Position_XY');\nposz = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Position__Z');\nstime = 1;\nrange = 100;\noffset = $bm_sum(offset, $bm_mul(lag, no));\nlagx = $bm_mul(lposxy[0], no);\nlagy = $bm_mul(lposxy[1], no);\nlagz = $bm_mul(lposz, no);\noffsetXY = $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Offset_XY'), 0.001);\noffsetZ = $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Offset__Z'), 0.001);\noffsetXY[0] = $bm_sum(offset, $bm_mul(offsetXY[0], no));\noffsetXY[1] = $bm_sum(offset, $bm_mul(offsetXY[1], no));\noffsetZ = $bm_sum(offset, $bm_mul(offsetZ, no));\ndecayspeed = $bm_mul(Math.abs(decay), 0.2);\ndisplacementXYZ = $bm_mul(displacementXYZ, Math.exp($bm_mul(ttx, decayspeed)));\n$bm_rt = rangexy = $bm_sum(rangexy, [\n    $bm_mul(lagren, no),\n    $bm_mul(lagren, no)\n]);\nif (huriko == true) {\n    x = $bm_mul(Math.sin($bm_sum($bm_mul($bm_mul($bm_mul(splagXY[0], displacementXYZ), Math.PI), stime), offsetXY[0])), Math.exp($bm_mul(ttx, decay)));\n    y = $bm_mul(Math.sin($bm_sum($bm_mul($bm_mul($bm_mul(splagXY[1], displacementXYZ), Math.PI), stime), offsetXY[1])), Math.exp($bm_mul(ttx, decay)));\n    z = $bm_mul(Math.sin($bm_sum($bm_mul($bm_mul($bm_mul(splagZ, displacementXYZ), Math.PI), stime), offsetZ)), Math.exp($bm_mul(ttx, decay)));\n    try {\n        $bm_rt = [\n            rangexy[0] * Math.sin(x * (range * 0.01) + angle) + value[0] + posxy[0] + lagx,\n            rangexy[1] * Math.cos(y * (range * 0.01) + angle) + value[1] + posxy[1] + lagy,\n            rangez * Math.cos(z * (range * 0.01) + angle) + value[2] + posz + lagz\n        ];\n    } catch (e) {\n        $bm_rt = [\n            rangexy[0] * Math.sin(x * (range * 0.01) + angle) + value[0] + posxy[0] + lagx,\n            rangexy[1] * Math.cos(y * (range * 0.01) + angle) + value[1] + posxy[1] + lagy\n        ];\n    }\n} else {\n    x = $bm_mul($bm_mul(rangexy[0], Math.sin($bm_sum($bm_mul($bm_mul($bm_mul(splagXY[0], displacementXYZ), Math.PI), stime), offsetXY[0]))), Math.exp($bm_mul(ttx, decay)));\n    if (bounceX != false) {\n        x = Math.abs(x);\n    }\n    y = $bm_mul($bm_mul(rangexy[1], Math.cos($bm_sum($bm_mul($bm_mul($bm_mul(splagXY[1], displacementXYZ), Math.PI), stime), offsetXY[1]))), Math.exp($bm_mul(ttx, decay)));\n    if (bounceY != false) {\n        y = $bm_mul(Math.abs(y), -1);\n    }\n    z = $bm_mul($bm_mul(rangez, Math.cos($bm_sum($bm_mul($bm_mul($bm_mul(splagZ, displacementXYZ), Math.PI), stime), offsetZ))), Math.exp($bm_mul(ttx, decay)));\n    if (bounceZ != false) {\n        z = Math.abs(z);\n    }\n    try {\n        $bm_rt = [\n            x + value[0] + posxy[0] + lagx,\n            y + value[1] + posxy[1] + lagy,\n            z + value[2] + posz + lagz\n        ];\n    } catch (e) {\n        $bm_rt = [\n            x + value[0] + posxy[0] + lagx,\n            y + value[1] + posxy[1] + lagy\n        ];\n    }\n}"},"a":{"a":0,"k":[359.893,574,0],"ix":1,"x":"var $bm_rt;\nvar a, b;\na = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Anchorpoint_XY');\nb = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Anchorpoint__Z');\ntry {\n    $bm_rt = [\n        a[0] + value[0],\n        a[1] + value[1],\n        b + value[2]\n    ];\n} catch (e) {\n    $bm_rt = [\n        a[0] + value[0],\n        a[1] + value[1]\n    ];\n}"},"s":{"a":0,"k":[330,330,330],"ix":6,"x":"var $bm_rt;\nvar a, b;\na = $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Scale_XY(%)'), 0.01);\nb = $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Scale__Z'), 0.01);\ntry {\n    $bm_rt = [\n        a[0] * value[0],\n        a[1] * value[1],\n        b * value[2]\n    ];\n} catch (e) {\n    $bm_rt = [\n        a[0] * value[0],\n        a[1] * value[1]\n    ];\n}"}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[23.051,-12.73],[12.73,23.051],[-23.051,12.73],[-12.731,-23.051]],"o":[[23.051,12.73],[-12.731,23.051],[-23.051,-12.73],[12.73,-23.051]],"v":[[23.051,0],[-0.001,23.051],[-23.051,0],[-0.001,-23.051]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false,"_render":true},{"ty":"fl","c":{"a":0,"k":[0.6902,0.9098,0.9922,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false,"_render":true},{"ty":"tr","p":{"a":0,"k":[359.893,574],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform","_render":true}],"nm":"Group 1","np":2,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false,"_render":true}],"ip":0,"op":900.000036657751,"st":0,"bm":0,"completed":true},{"ddd":1,"ind":9,"ty":4,"nm":"          Layer 1 Outlines","parent":1,"sr":1,"ks":{"o":{"a":0,"k":100,"ix":11,"x":"var $bm_rt;\n$bm_rt = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Opacity(0~100)');"},"rx":{"a":0,"k":0,"ix":8,"x":"var $bm_rt;\nvar no, lag, rotax, r, r, rota, cycle, gtime, nKey, gtime, gtime, decay, gtime, nKey, ttx, ttx, cycle, ttx, cycle, baseTime, min, max, UP, Down;\nno = 1;\nlag = $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Rotation XY'), 0.1);\nrotax = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('RotationX');\nif (thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('ReverseRotation') == 1) {\n    r = 1;\n} else {\n    r = -1;\n}\n;\n$bm_rt = rota = $bm_mul(lag[0], no);\nif (thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('AutoRotation_X') == 1) {\n    cycle = $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Speed(XYZ)'), 0.01);\n    gtime = 0;\n    try {\n        nKey = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Decay(Scale)').nearestKey(0);\n        if (time >= nKey.time) {\n            gtime = $bm_sub(time, nKey.time);\n        } else {\n            gtime = $bm_sub(time, nKey.time);\n            if (gtime < 0) {\n                decay = 0;\n            }\n        }\n    } catch (e) {\n        gtime = time;\n        nKey = 'NaN';\n    }\n    ;\n    if (nKey == 'NaN') {\n        ttx = $bm_sub(time, thisLayer.inPoint);\n    } else {\n        ttx = gtime;\n    }\n    ;\n    cycle = $bm_mul(cycle, Math.exp($bm_mul($bm_mul(ttx, thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Decay(Scale)')), 0.01)));\n    if (cycle == 0) {\n        ttx = 1;\n        cycle = 1;\n    }\n    ;\n    baseTime = $bm_mod(ttx, $bm_div(1, cycle));\n    min = 0;\n    max = $bm_mul(360, r);\n    UP = linear(baseTime, 0, $bm_div(1, cycle), min, max);\n    Down = linear(baseTime, $bm_div(1, cycle), cycle, max, min);\n    $bm_rt = baseTime < $bm_div(1, cycle) ? $bm_sum($bm_sum($bm_sum(UP, value), rota), rotax) : $bm_sum($bm_sum($bm_sum(Down, value), rota), rotax);\n} else {\n    $bm_rt = $bm_sum($bm_sum(value, rota), rotax);\n}"},"ry":{"a":0,"k":0,"ix":9,"x":"var $bm_rt;\nvar no, lag, rotay, r, r, rota, cycle, gtime, nKey, gtime, gtime, decay, gtime, nKey, ttx, ttx, cycle, ttx, cycle, baseTime, min, max, UP, Down;\nno = 1;\nlag = $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Rotation XY'), 0.1);\nrotay = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('RotationY');\nif (thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('ReverseRotation') == 1) {\n    r = 1;\n} else {\n    r = -1;\n}\n;\n$bm_rt = rota = $bm_mul(lag[1], no);\nif (thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('AutoRotation_Y') == 1) {\n    cycle = $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Speed(XYZ)'), 0.01);\n    gtime = 0;\n    try {\n        nKey = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Decay(Scale)').nearestKey(0);\n        if (time >= nKey.time) {\n            gtime = $bm_sub(time, nKey.time);\n        } else {\n            gtime = $bm_sub(time, nKey.time);\n            if (gtime < 0) {\n                decay = 0;\n            }\n        }\n    } catch (e) {\n        gtime = time;\n        nKey = 'NaN';\n    }\n    ;\n    if (nKey == 'NaN') {\n        ttx = $bm_sub(time, thisLayer.inPoint);\n    } else {\n        ttx = gtime;\n    }\n    ;\n    cycle = $bm_mul(cycle, Math.exp($bm_mul($bm_mul(ttx, thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Decay(Scale)')), 0.01)));\n    if (cycle == 0) {\n        ttx = 1;\n        cycle = 1;\n    }\n    ;\n    baseTime = $bm_mod(ttx, $bm_div(1, cycle));\n    min = 0;\n    max = $bm_mul(360, r);\n    UP = linear(baseTime, 0, $bm_div(1, cycle), min, max);\n    Down = linear(baseTime, $bm_div(1, cycle), cycle, max, min);\n    $bm_rt = baseTime < $bm_div(1, cycle) ? $bm_sum($bm_sum($bm_sum(UP, value), rota), rotay) : $bm_sum($bm_sum($bm_sum(Down, value), rota), rotay);\n} else {\n    $bm_rt = $bm_sum($bm_sum(value, rota), rotay);\n}"},"rz":{"a":0,"k":0,"ix":10,"x":"var $bm_rt;\nvar no, lag, rotaz, r, r, rota, cycle, gtime, nKey, gtime, gtime, decay, gtime, nKey, ttx, ttx, cycle, ttx, cycle, baseTime, min, max, UP, Down;\nno = 1;\nlag = $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Rotation  Z'), 0.1);\nrotaz = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('RotationZ');\nif (thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('ReverseRotation') == 1) {\n    r = 1;\n} else {\n    r = -1;\n}\n;\n$bm_rt = rota = $bm_mul(lag, no);\nif (thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('AutoRotation_Z') == 1) {\n    cycle = $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Speed(XYZ)'), 0.01);\n    gtime = 0;\n    try {\n        nKey = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Decay(Scale)').nearestKey(0);\n        if (time >= nKey.time) {\n            gtime = $bm_sub(time, nKey.time);\n        } else {\n            gtime = $bm_sub(time, nKey.time);\n            if (gtime < 0) {\n                decay = 0;\n            }\n        }\n    } catch (e) {\n        gtime = time;\n        nKey = 'NaN';\n    }\n    ;\n    if (nKey == 'NaN') {\n        ttx = $bm_sub(time, thisLayer.inPoint);\n    } else {\n        ttx = gtime;\n    }\n    ;\n    cycle = $bm_mul(cycle, Math.exp($bm_mul($bm_mul(ttx, thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Decay(Scale)')), 0.01)));\n    if (cycle == 0) {\n        ttx = 1;\n        cycle = 1;\n    }\n    ;\n    baseTime = $bm_mod(ttx, $bm_div(1, cycle));\n    min = 0;\n    max = $bm_mul(360, r);\n    UP = linear(baseTime, 0, $bm_div(1, cycle), min, max);\n    Down = linear(baseTime, $bm_div(1, cycle), cycle, max, min);\n    $bm_rt = baseTime < $bm_div(1, cycle) ? $bm_sum($bm_sum($bm_sum(UP, value), rota), rotaz) : $bm_sum($bm_sum($bm_sum(Down, value), rota), rotaz);\n} else {\n    $bm_rt = $bm_sum($bm_sum(value, rota), rotaz);\n}"},"or":{"a":0,"k":[0,0,0],"ix":7,"x":"var $bm_rt;\nvar a, o, tr, tr, o, o, o;\na = [\n    0,\n    0,\n    0\n];\no = [\n    0,\n    0,\n    0\n];\ntry {\n    tr = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Target');\n} catch (e) {\n    tr = 0;\n}\nif (tr != 0) {\n    try {\n        if (this.parent) {\n            o = lookAt($bm_sum($bm_transform.position, this.parent.position), tr.position);\n        } else {\n            o = lookAt($bm_transform.position, tr.position);\n        }\n        ;\n    } catch (e) {\n        o = lookAt($bm_transform.position, tr.position);\n    }\n}\n;\nif (thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('FollowTarget_X') == 1) {\n    a[0] = o[0];\n}\nif (thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('FollowTarget_Y') == 1) {\n    a[1] = o[1];\n}\nif (thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('FollowTarget_Z') == 1) {\n    a[2] = o[2];\n}\n$bm_rt = $bm_sum(a, value);"},"p":{"a":0,"k":[10,10,0],"ix":2,"x":"var $bm_rt;\nvar huriko, bounceX, bounceY, bounceZ, rangexy, rangez, angle, offset, lag, lagren, lposxy, lposz, decay, displacementXYZ, splagXY, splagZ, gtime, nKey, gtime, gtime, decay, gtime, nKey, ttx, ttx, posxy, posz, stime, range, offset, lagx, lagy, lagz, offsetXY, offsetZ, offsetZ, decayspeed, displacementXYZ, rangexy, x, y, z, x, x, y, y, z, z;\nvar no = 1;\nhuriko = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Pendulum ON');\nbounceX = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Bounce_X');\nbounceY = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Bounce_Y');\nbounceZ = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Bounce_Z');\nrangexy = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Scale XY');\nrangez = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Scale  Z');\nangle = degreesToRadians($bm_sum(180, $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Angle(Pendulum only)'), -1)));\noffset = $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Offset'), 0.01);\nlag = $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Shift'), 0.01);\nlagren = $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Scale(xy)'), 0.1);\nlposxy = $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Position XY'), 0.1);\nlposz = $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Position  Z'), 0.1);\ndecay = $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Decay(Scale)'), 0.01);\ndisplacementXYZ = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM_speedXYZ[delete prohibited]')('ADBE Slider Control-0001');\nsplagXY = $bm_sum([\n    1,\n    1\n], $bm_mul($bm_mul(no, thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Speed XY')), 0.0001));\nsplagZ = $bm_sum(1, $bm_mul($bm_mul(no, thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Speed Z')), 0.0001));\ngtime = 0;\ntry {\n    nKey = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Decay(Scale)').nearestKey(0);\n    if (time >= nKey.time) {\n        gtime = $bm_sub(time, nKey.time);\n    } else {\n        gtime = $bm_sub(time, nKey.time);\n        if (gtime < 0) {\n            decay = 0;\n        }\n    }\n} catch (e) {\n    gtime = time;\n    nKey = 'NaN';\n}\n;\nif (nKey == 'NaN') {\n    ttx = $bm_sub(time, thisLayer.inPoint);\n} else {\n    ttx = gtime;\n}\n;\nposxy = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Position_XY');\nposz = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Position__Z');\nstime = 1;\nrange = 100;\noffset = $bm_sum(offset, $bm_mul(lag, no));\nlagx = $bm_mul(lposxy[0], no);\nlagy = $bm_mul(lposxy[1], no);\nlagz = $bm_mul(lposz, no);\noffsetXY = $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Offset_XY'), 0.001);\noffsetZ = $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Offset__Z'), 0.001);\noffsetXY[0] = $bm_sum(offset, $bm_mul(offsetXY[0], no));\noffsetXY[1] = $bm_sum(offset, $bm_mul(offsetXY[1], no));\noffsetZ = $bm_sum(offset, $bm_mul(offsetZ, no));\ndecayspeed = $bm_mul(Math.abs(decay), 0.2);\ndisplacementXYZ = $bm_mul(displacementXYZ, Math.exp($bm_mul(ttx, decayspeed)));\n$bm_rt = rangexy = $bm_sum(rangexy, [\n    $bm_mul(lagren, no),\n    $bm_mul(lagren, no)\n]);\nif (huriko == true) {\n    x = $bm_mul(Math.sin($bm_sum($bm_mul($bm_mul($bm_mul(splagXY[0], displacementXYZ), Math.PI), stime), offsetXY[0])), Math.exp($bm_mul(ttx, decay)));\n    y = $bm_mul(Math.sin($bm_sum($bm_mul($bm_mul($bm_mul(splagXY[1], displacementXYZ), Math.PI), stime), offsetXY[1])), Math.exp($bm_mul(ttx, decay)));\n    z = $bm_mul(Math.sin($bm_sum($bm_mul($bm_mul($bm_mul(splagZ, displacementXYZ), Math.PI), stime), offsetZ)), Math.exp($bm_mul(ttx, decay)));\n    try {\n        $bm_rt = [\n            rangexy[0] * Math.sin(x * (range * 0.01) + angle) + value[0] + posxy[0] + lagx,\n            rangexy[1] * Math.cos(y * (range * 0.01) + angle) + value[1] + posxy[1] + lagy,\n            rangez * Math.cos(z * (range * 0.01) + angle) + value[2] + posz + lagz\n        ];\n    } catch (e) {\n        $bm_rt = [\n            rangexy[0] * Math.sin(x * (range * 0.01) + angle) + value[0] + posxy[0] + lagx,\n            rangexy[1] * Math.cos(y * (range * 0.01) + angle) + value[1] + posxy[1] + lagy\n        ];\n    }\n} else {\n    x = $bm_mul($bm_mul(rangexy[0], Math.sin($bm_sum($bm_mul($bm_mul($bm_mul(splagXY[0], displacementXYZ), Math.PI), stime), offsetXY[0]))), Math.exp($bm_mul(ttx, decay)));\n    if (bounceX != false) {\n        x = Math.abs(x);\n    }\n    y = $bm_mul($bm_mul(rangexy[1], Math.cos($bm_sum($bm_mul($bm_mul($bm_mul(splagXY[1], displacementXYZ), Math.PI), stime), offsetXY[1]))), Math.exp($bm_mul(ttx, decay)));\n    if (bounceY != false) {\n        y = $bm_mul(Math.abs(y), -1);\n    }\n    z = $bm_mul($bm_mul(rangez, Math.cos($bm_sum($bm_mul($bm_mul($bm_mul(splagZ, displacementXYZ), Math.PI), stime), offsetZ))), Math.exp($bm_mul(ttx, decay)));\n    if (bounceZ != false) {\n        z = Math.abs(z);\n    }\n    try {\n        $bm_rt = [\n            x + value[0] + posxy[0] + lagx,\n            y + value[1] + posxy[1] + lagy,\n            z + value[2] + posz + lagz\n        ];\n    } catch (e) {\n        $bm_rt = [\n            x + value[0] + posxy[0] + lagx,\n            y + value[1] + posxy[1] + lagy\n        ];\n    }\n}"},"a":{"a":0,"k":[282.051,574,0],"ix":1,"x":"var $bm_rt;\nvar a, b;\na = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Anchorpoint_XY');\nb = thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Anchorpoint__Z');\ntry {\n    $bm_rt = [\n        a[0] + value[0],\n        a[1] + value[1],\n        b + value[2]\n    ];\n} catch (e) {\n    $bm_rt = [\n        a[0] + value[0],\n        a[1] + value[1]\n    ];\n}"},"s":{"a":0,"k":[330,330,330],"ix":6,"x":"var $bm_rt;\nvar a, b;\na = $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Scale_XY(%)'), 0.01);\nb = $bm_mul(thisComp.layer('[CircularControl]1]_          Layer 1 Outlines').effect('ACM')('Scale__Z'), 0.01);\ntry {\n    $bm_rt = [\n        a[0] * value[0],\n        a[1] * value[1],\n        b * value[2]\n    ];\n} catch (e) {\n    $bm_rt = [\n        a[0] * value[0],\n        a[1] * value[1]\n    ];\n}"}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[23.051,-12.73],[12.73,23.051],[-23.051,12.73],[-12.731,-23.051]],"o":[[23.051,12.73],[-12.731,23.051],[-23.051,-12.73],[12.73,-23.051]],"v":[[23.051,0],[-0.001,23.051],[-23.051,0],[-0.001,-23.051]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false,"_render":true},{"ty":"fl","c":{"a":0,"k":[0,0.5333,1,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false,"_render":true},{"ty":"tr","p":{"a":0,"k":[282.051,574],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform","_render":true}],"nm":"Group 1","np":2,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false,"_render":true}],"ip":0,"op":900.000036657751,"st":0,"bm":0,"completed":true}],"markers":[{"tm":0,"cm":"1","dr":0}],"__complete":true}